{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"liquidpy A port of liquid template engine for python, on the shoulder of jinja2 Install pip install -U liquidpy Baisic usage Loading a template from liquid import Liquid liq = Liquid ( '{{a}}' , from_file = False ) ret = liq . render ( a = 1 ) # ret == '1' # load template from a file liq = Liquid ( '/path/to/template.html' ) Using jinja's environment from jinja2 import Environment , FileSystemLoader env = Environment ( loader = FileSystemLoader ( './' ), ... ) liq = Liquid . from_env ( \"/path/to/template.html\" , env ) Switching to a different mode liq = Liquid ( \"\"\" {% python %} from os import path filename = path.join(\"a\", \"b\") {% endpython %} {{filename}} \"\"\" , mode = \"wild\" # supported: standard(default), jekyll, shopify, wild ) liq . render () # 'a/b' Changing default options from liquid import defaults , Liquid defaults . FROM_FILE = False defaults . MODE = 'wild' # no need to pass from_file and mode anymore liq = Liquid ( '{ % f rom_ os import path %}{{path.basename(\"a/b.txt\")}}' ) liq . render () # 'b.txt' Documentation Liquidpy's documentation Liquid documentation (standard) Liquid documentation (jekyll) Liquid documentation (shopify-extended) Jinja2's documentation","title":"Home"},{"location":"#liquidpy","text":"A port of liquid template engine for python, on the shoulder of jinja2","title":"liquidpy"},{"location":"#install","text":"pip install -U liquidpy","title":"Install"},{"location":"#baisic-usage","text":"","title":"Baisic usage"},{"location":"#loading-a-template","text":"from liquid import Liquid liq = Liquid ( '{{a}}' , from_file = False ) ret = liq . render ( a = 1 ) # ret == '1' # load template from a file liq = Liquid ( '/path/to/template.html' ) Using jinja's environment from jinja2 import Environment , FileSystemLoader env = Environment ( loader = FileSystemLoader ( './' ), ... ) liq = Liquid . from_env ( \"/path/to/template.html\" , env )","title":"Loading a template"},{"location":"#switching-to-a-different-mode","text":"liq = Liquid ( \"\"\" {% python %} from os import path filename = path.join(\"a\", \"b\") {% endpython %} {{filename}} \"\"\" , mode = \"wild\" # supported: standard(default), jekyll, shopify, wild ) liq . render () # 'a/b'","title":"Switching to a different mode"},{"location":"#changing-default-options","text":"from liquid import defaults , Liquid defaults . FROM_FILE = False defaults . MODE = 'wild' # no need to pass from_file and mode anymore liq = Liquid ( '{ % f rom_ os import path %}{{path.basename(\"a/b.txt\")}}' ) liq . render () # 'b.txt'","title":"Changing default options"},{"location":"#documentation","text":"Liquidpy's documentation Liquid documentation (standard) Liquid documentation (jekyll) Liquid documentation (shopify-extended) Jinja2's documentation","title":"Documentation"},{"location":"basics/","text":"Mode of a template liquidpy supports 4 modes: standard try to be compatible with standard liquid template engine See: https://shopify.github.io/liquid/ jekyll try to be compatible with jekyll liquid template engine See: https://jekyllrb.com/docs/liquid/ shopify try to be compatible with shopify-extended liquid template engine See: https://shopify.dev/api/liquid wild With some wild features supported (i.e. executing python code inside the template) See: https://pwwang.github.io/liquidpy/wild See also an introduction about liquid template engine variants: https://shopify.github.io/liquid/basics/variations/ By default, liquidpy uses the standard mode. But you can specify a mode using the mode argument of Liquid constructor or Liquid.from_env() method. You can changed the default by: from liquid import defaults defaults . MODE = 'wild' before you initialize a Liquid object. Preset globals and filters If you want to send a set of global variables and filters to the templates: from liquid import Liquid , defaults defaults . FROM_FILE = False a = 1 b = 2 Liquid ( \"{{a | plus: b}}\" , globals = globals ()) . render () # '3' Specify predefined filters: import os from liquid import Liquid , defaults defaults . FROM_FILE = False Liquid ( \"{{'/a' | path_join: 'b'}}\" , filters = { 'path_join' : os . path . join }) . render () # '/a/b' Relationship with Jinja2/3 Most features here are implemented by jinja extensions. Some of them, however, are impossible to implement via extensions. So we monkey-patched jinja to be better compatible with liquid syntax. Note If you want jinja to work as its original way, remember to unpatch it before you parse and render your template: from jinja2 import Template from liquid import Liquid , patch_jinja , unpatch_jinja liq_tpl = Liquid ( ... ) liq_tpl . render ( ... ) # works jinja_tpl = Template ( ... ) # error may happen jinja_tpl . render ( ... ) # error may happen unpatch_jinja () # restore jinja jinja_tpl = Template ( ... ) # works jinja_tpl . render ( ... ) # works liq_tpl . render ( ... ) # error may happen patch_jinja () # patch jinja again liq_tpl . render ( ... ) # works Most jinja features are supported unless the filters/tags are overriden. For example, the round() filter acts differently then the one in jinja . We could say that the implementations of liquid and its variants are super sets of them themselves, with some slight compatibility issues (See Compatilities below.) Whitespace control The whitespace control behaves the same as it describes here: https://shopify.github.io/liquid/basics/whitespace/ Compatibilies See the compatiblity issues for truthy/falsy, tags, and other aspects on pages: Standard: https://pwwang.github.com/liquidpy/standard Jekyll: https://pwwang.github.com/liquidpy/jekyll Shopify: https://pwwang.github.com/liquidpy/shopify Wild mode You can do arbitrary things with the wild mode, like executing python code and adding custom filters inside the template. See details on: https://pwwang.github.com/liquidpy/wild","title":"Basics"},{"location":"basics/#mode-of-a-template","text":"liquidpy supports 4 modes: standard try to be compatible with standard liquid template engine See: https://shopify.github.io/liquid/ jekyll try to be compatible with jekyll liquid template engine See: https://jekyllrb.com/docs/liquid/ shopify try to be compatible with shopify-extended liquid template engine See: https://shopify.dev/api/liquid wild With some wild features supported (i.e. executing python code inside the template) See: https://pwwang.github.io/liquidpy/wild See also an introduction about liquid template engine variants: https://shopify.github.io/liquid/basics/variations/ By default, liquidpy uses the standard mode. But you can specify a mode using the mode argument of Liquid constructor or Liquid.from_env() method. You can changed the default by: from liquid import defaults defaults . MODE = 'wild' before you initialize a Liquid object.","title":"Mode of a template"},{"location":"basics/#preset-globals-and-filters","text":"If you want to send a set of global variables and filters to the templates: from liquid import Liquid , defaults defaults . FROM_FILE = False a = 1 b = 2 Liquid ( \"{{a | plus: b}}\" , globals = globals ()) . render () # '3' Specify predefined filters: import os from liquid import Liquid , defaults defaults . FROM_FILE = False Liquid ( \"{{'/a' | path_join: 'b'}}\" , filters = { 'path_join' : os . path . join }) . render () # '/a/b'","title":"Preset globals and filters"},{"location":"basics/#relationship-with-jinja23","text":"Most features here are implemented by jinja extensions. Some of them, however, are impossible to implement via extensions. So we monkey-patched jinja to be better compatible with liquid syntax. Note If you want jinja to work as its original way, remember to unpatch it before you parse and render your template: from jinja2 import Template from liquid import Liquid , patch_jinja , unpatch_jinja liq_tpl = Liquid ( ... ) liq_tpl . render ( ... ) # works jinja_tpl = Template ( ... ) # error may happen jinja_tpl . render ( ... ) # error may happen unpatch_jinja () # restore jinja jinja_tpl = Template ( ... ) # works jinja_tpl . render ( ... ) # works liq_tpl . render ( ... ) # error may happen patch_jinja () # patch jinja again liq_tpl . render ( ... ) # works Most jinja features are supported unless the filters/tags are overriden. For example, the round() filter acts differently then the one in jinja . We could say that the implementations of liquid and its variants are super sets of them themselves, with some slight compatibility issues (See Compatilities below.)","title":"Relationship with Jinja2/3"},{"location":"basics/#whitespace-control","text":"The whitespace control behaves the same as it describes here: https://shopify.github.io/liquid/basics/whitespace/","title":"Whitespace control"},{"location":"basics/#compatibilies","text":"See the compatiblity issues for truthy/falsy, tags, and other aspects on pages: Standard: https://pwwang.github.com/liquidpy/standard Jekyll: https://pwwang.github.com/liquidpy/jekyll Shopify: https://pwwang.github.com/liquidpy/shopify","title":"Compatibilies"},{"location":"basics/#wild-mode","text":"You can do arbitrary things with the wild mode, like executing python code and adding custom filters inside the template. See details on: https://pwwang.github.com/liquidpy/wild","title":"Wild mode"},{"location":"changelog/","text":"0.7.3 \ud83e\ude79 Make default filter work with None \ud83e\ude79 Make attr filter work with dicts \ud83e\ude79 Use filter liquid_map , in wild mode, instead of map , which is overridden by python's builtin map 0.7.2 \ud83d\udc1b Fix date filter issues (#38, #40) \u2728 Add markdownify for jekyll (#36, #37) \u2728 Add number_of_words for jekyll \u2728 Add jekyll filter sort \u2728 Add jekyll filter slugify \u2728 Add jekyll filter array_to_sentence_string \u2728 Add jekyll filter jsonify \u2728 Add jekyll filters xml_escape , cgi_escape and uri_escape \u2728 Add int , float , str and bool as both filters and globals for all modes (#40) 0.7.1 \u2728 Add regex_replace filter \u2728 Allow absolute path and pathlib.Path passed as template files \u2728 Allow +/- to work with date filter (#38) \u2728 Add filters_as_globals for wild mode (defaults to True ) 0.7.0 Reimplement using jinja2 0.6.4 Last release of 0.6, for compatibilities. Add regex_replace filter (#33) 0.6.3 Allow tag for to have output(test | filter) in python mode. Fix stacks not print in some cases. Avoid closing stream after parsing Add better error message for attribute error while rendering Print 'KeyError' for render error if it is a KeyError. 0.6.2 Update dependency versions 0.6.1 Fix use of LiquidPython Add getitem and render filter for python mode Fix EmptyDrop for variable segment in python mode Fix re-rendering error for extends tag (#29) 0.6.0 Remodel the package to use a lexer to scan the nodes first and then lark-parse to parse the tag. 0.5.0 Extract major model of node to allow register_node (#18) Introduce config node and deprecate mode Allow specification of directories to scan for include and extends (#19) Add loglevel detail to enable verbosity between info and debug Allow passing variables to included templates (#8) Disallow variables in parent templates to be modified in included templates Require backtick ( ` ) for liquidpy expression to be used in statement nodes Add API documentations 0.4.0 Implement issue #13: Adding ternary end modifier ( $ ) Expand list/dict context in debug information 0.3.0 Force explict modifiers (=/!) for True/False action in ternary filters Add combined ternary filters Add shortcut ? for ?bool Use the maximum lineno on traceback instead of the last one. 0.2.3 Fix parsing errors when unicode in a template loaded from text #10 (thanks to vermeeca) 0.2.2 Show shortened context in debug information Fix #9: stream cursor shifted when unicode in the template. 0.2.1 Fix #7: forloop problem with nesting for statements Fix other bugs 0.2.0 Add inclusion and inheritance support Add cycle for for loop 0.1.0 Rewrite whole engine using a stream parser Support multi-line for statements, expressions and tag comments (#1) Support wrapper (instead of a single prefix) for statement comments Add from and import shortcuts to import python modules Support expressions in if/unless/while statements Support liquid forloop object for for statement (#2) Improve debug information Add arguemtn position specification for filters Add tenary filters Remove & modifiers 0.0.7 Allow {% mode %} block to be anywhere in the source code Full the coverage Change support only for python3.5+ 0.0.6 Add modifiers & and * to allow chaining and expanding arguments","title":"Change log"},{"location":"changelog/#073","text":"\ud83e\ude79 Make default filter work with None \ud83e\ude79 Make attr filter work with dicts \ud83e\ude79 Use filter liquid_map , in wild mode, instead of map , which is overridden by python's builtin map","title":"0.7.3"},{"location":"changelog/#072","text":"\ud83d\udc1b Fix date filter issues (#38, #40) \u2728 Add markdownify for jekyll (#36, #37) \u2728 Add number_of_words for jekyll \u2728 Add jekyll filter sort \u2728 Add jekyll filter slugify \u2728 Add jekyll filter array_to_sentence_string \u2728 Add jekyll filter jsonify \u2728 Add jekyll filters xml_escape , cgi_escape and uri_escape \u2728 Add int , float , str and bool as both filters and globals for all modes (#40)","title":"0.7.2"},{"location":"changelog/#071","text":"\u2728 Add regex_replace filter \u2728 Allow absolute path and pathlib.Path passed as template files \u2728 Allow +/- to work with date filter (#38) \u2728 Add filters_as_globals for wild mode (defaults to True )","title":"0.7.1"},{"location":"changelog/#070","text":"Reimplement using jinja2","title":"0.7.0"},{"location":"changelog/#064","text":"Last release of 0.6, for compatibilities. Add regex_replace filter (#33)","title":"0.6.4"},{"location":"changelog/#063","text":"Allow tag for to have output(test | filter) in python mode. Fix stacks not print in some cases. Avoid closing stream after parsing Add better error message for attribute error while rendering Print 'KeyError' for render error if it is a KeyError.","title":"0.6.3"},{"location":"changelog/#062","text":"Update dependency versions","title":"0.6.2"},{"location":"changelog/#061","text":"Fix use of LiquidPython Add getitem and render filter for python mode Fix EmptyDrop for variable segment in python mode Fix re-rendering error for extends tag (#29)","title":"0.6.1"},{"location":"changelog/#060","text":"Remodel the package to use a lexer to scan the nodes first and then lark-parse to parse the tag.","title":"0.6.0"},{"location":"changelog/#050","text":"Extract major model of node to allow register_node (#18) Introduce config node and deprecate mode Allow specification of directories to scan for include and extends (#19) Add loglevel detail to enable verbosity between info and debug Allow passing variables to included templates (#8) Disallow variables in parent templates to be modified in included templates Require backtick ( ` ) for liquidpy expression to be used in statement nodes Add API documentations","title":"0.5.0"},{"location":"changelog/#040","text":"Implement issue #13: Adding ternary end modifier ( $ ) Expand list/dict context in debug information","title":"0.4.0"},{"location":"changelog/#030","text":"Force explict modifiers (=/!) for True/False action in ternary filters Add combined ternary filters Add shortcut ? for ?bool Use the maximum lineno on traceback instead of the last one.","title":"0.3.0"},{"location":"changelog/#023","text":"Fix parsing errors when unicode in a template loaded from text #10 (thanks to vermeeca)","title":"0.2.3"},{"location":"changelog/#022","text":"Show shortened context in debug information Fix #9: stream cursor shifted when unicode in the template.","title":"0.2.2"},{"location":"changelog/#021","text":"Fix #7: forloop problem with nesting for statements Fix other bugs","title":"0.2.1"},{"location":"changelog/#020","text":"Add inclusion and inheritance support Add cycle for for loop","title":"0.2.0"},{"location":"changelog/#010","text":"Rewrite whole engine using a stream parser Support multi-line for statements, expressions and tag comments (#1) Support wrapper (instead of a single prefix) for statement comments Add from and import shortcuts to import python modules Support expressions in if/unless/while statements Support liquid forloop object for for statement (#2) Improve debug information Add arguemtn position specification for filters Add tenary filters Remove & modifiers","title":"0.1.0"},{"location":"changelog/#007","text":"Allow {% mode %} block to be anywhere in the source code Full the coverage Change support only for python3.5+","title":"0.0.7"},{"location":"changelog/#006","text":"Add modifiers & and * to allow chaining and expanding arguments","title":"0.0.6"},{"location":"jekyll/","text":"You may checkout the documentation for jekyll liquid: https://jekyllrb.com/docs/liquid/ The compatibility issues list on: https://pwwang.github.com/liquidpy/standard also applied in jekyll mode. Besides, passing variables to a sub-template using include tag is not supported. Instead, please using jinja's with tag: https://stackoverflow.com/a/9405157/5088165","title":"Compatibility with jekyll liquid"},{"location":"shopify/","text":"You may checkout the documentation for shopfiy liquid: https://shopify.dev/api/liquid The compatibility issues list on: https://pwwang.github.com/liquidpy/standard also applied in shopify mode.","title":"Compatibility with shopify-extended liquid"},{"location":"standard/","text":"You may checkout the documentation for standard liquid: - https://shopify.github.io/liquid/ liquidpy tries to maintain the maximum compatibility with liquid . But we do have some differences: Filter round() It always returns a float rather than an integer when ndigits=0 Logical operators The logical operators and / or collapse from left to right (it's right to left in liquid ) See: https://shopify.github.io/liquid/basics/operators/#order-of-operations Truthy and falsy Instead of always truthy for empty string, 0, empty array, they are falsy in liquidpy Iteration Literal ranges ( (1..5) ) are suported by liquidpy . However, the start and the stop must be integers or names, meaning this is not supported (1..array.size) . You can do this instead: {% assign asize = array.size %} {% for i in ( 1 ..asize) %} ... {% endfor %} Typecasting You are able to do the following in ruby liquid: {{ \"1\" | plus : 1 }} # 2 However, this is not valid in liquidpy. Because the template is eventually compiled into python code and the type handling is delegated to python, but \"1\" + 1 is not a valid python operation. So you have to do typecasting yourself: {{ \"1\" | int | plus : 1 }} # 2 In order to make it work, extra filters int , float , str and bool are added as builtin filters. They are also added as globals in order to get this work: {% capture lst_size %} 4 {% endcapture %} {{ 2 | at_most : int(lst_size) }} # 2 See also: https://github.com/pwwang/liquidpy/issues/40","title":"Compatibility with standard liquid"},{"location":"standard/#filter-round","text":"It always returns a float rather than an integer when ndigits=0","title":"Filter round()"},{"location":"standard/#logical-operators","text":"The logical operators and / or collapse from left to right (it's right to left in liquid ) See: https://shopify.github.io/liquid/basics/operators/#order-of-operations","title":"Logical operators"},{"location":"standard/#truthy-and-falsy","text":"Instead of always truthy for empty string, 0, empty array, they are falsy in liquidpy","title":"Truthy and falsy"},{"location":"standard/#iteration","text":"Literal ranges ( (1..5) ) are suported by liquidpy . However, the start and the stop must be integers or names, meaning this is not supported (1..array.size) . You can do this instead: {% assign asize = array.size %} {% for i in ( 1 ..asize) %} ... {% endfor %}","title":"Iteration"},{"location":"standard/#typecasting","text":"You are able to do the following in ruby liquid: {{ \"1\" | plus : 1 }} # 2 However, this is not valid in liquidpy. Because the template is eventually compiled into python code and the type handling is delegated to python, but \"1\" + 1 is not a valid python operation. So you have to do typecasting yourself: {{ \"1\" | int | plus : 1 }} # 2 In order to make it work, extra filters int , float , str and bool are added as builtin filters. They are also added as globals in order to get this work: {% capture lst_size %} 4 {% endcapture %} {{ 2 | at_most : int(lst_size) }} # 2 See also: https://github.com/pwwang/liquidpy/issues/40","title":"Typecasting"},{"location":"wild/","text":"Wild mode tries to introduce more flexiblities for the template. It's very arbitrary for one to do things inside the template. So security is not it's first priority. Warning Do not trust any templates in wild mode with liquidpy Below are some features it supports. Globals By default, wild mode loads all __builtins__ as global variables, except those whose names start with _ . nil is also loaded and intepreted as None . Other globals if not overridden by the above: See: https://jinja.palletsprojects.com/en/3.0.x/templates/?highlight=builtin%20filters#list-of-global-functions Filters All builtin functions are loaded as filters, except those whose names starts with _ and not in: \"copyright\", \"credits\", \"input\", \"help\", \"globals\", \"license\", \"locals\", \"memoryview\", \"object\", \"property\", \"staticmethod\", \"super\" . Filters from standard mode are loaded Builtin jinja filters are enabled if not overridden by the above filters See: https://jinja.palletsprojects.com/en/3.0.x/templates/?highlight=builtin%20filters#builtin-filters ifelse : See: https://pwwang.github.io/liquidpy/api/liquid.filters.wild/ map() It is overridden by python's builtins.map() . To use the one from liquid , try liquid_map() Tests All jinja tests are supported See: https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-tests Tags liquidpy wild mode supports a set of tags that we can do arbitrary things. python tag The python tag allows you to execute arbitrary code inside a template. It supports single line mode and block mode. If you just want execute a single line of python code: {% python a = 1 %} Or if you want to execute a chunk of code: {% python %} def func(x) ... b = func(a) {% endpython %} Note The python tag can only interact with the global variables. The variables in the context ( Context.vars ) cannot be referred and will not be affected. In the above examples, the first will write variable a the environment.globals or overwrite it. The second will use variable a in environment.globals and then write b to it. Tip Any variables declared at top level of the code gets stored in the environment.globals . If you don't want some to be stored, you should delete them using del Tip The code will be dedentated using textwrap.dedent and then send to exec . So: {% python %} [space][space]a [space][space]b {% endpython %} works as expected. But you can also write it like this: {% python %} [space][space]a [space][space]b {% endpython %} The first non-spaced line will be ignored. Tip You can also print stuff inside the code, which will be parsed as literals. import_ and from_ tags The import_ and from_ tags help users to import python modules into the environment.globals . It works the same as python's import and from ... import ... Note The import and from from jinja are kept and work as they are in jinja. addfilter tag This allows one to add a filter using python code. For example: {% addfilter trunc %} def trunc(string, n): return string[:n] {% endaddfilter %} {{ a | trunc : 3 }} When render with a=\"abcde\" , it gives: 'abc' Like the python tag, you can only use the variables in environment.globals inside the code. But unlike the python tag, anything you print inside the code will be ignored. You can also define a filter with the environment: {% addfilter render pass_env %} def render(env, expr, **kwargs): compiled = env.compile_expression(expr) return compiled(**kwargs) {% endaddfilter %} {{ \" item | plus(1)\" | render : a }} When render with a=1 , it gives 2 . Note The expresison passed to env.compile_expression() has to use the jinja-supported syntax (i.e. using colon to separate filter and its arguments is not supported). This is useful when you want to render an template expression insdie the template. Extensions jinja2.ext.debug is enabled","title":"Wild mode"},{"location":"wild/#globals","text":"By default, wild mode loads all __builtins__ as global variables, except those whose names start with _ . nil is also loaded and intepreted as None . Other globals if not overridden by the above: See: https://jinja.palletsprojects.com/en/3.0.x/templates/?highlight=builtin%20filters#list-of-global-functions","title":"Globals"},{"location":"wild/#filters","text":"All builtin functions are loaded as filters, except those whose names starts with _ and not in: \"copyright\", \"credits\", \"input\", \"help\", \"globals\", \"license\", \"locals\", \"memoryview\", \"object\", \"property\", \"staticmethod\", \"super\" . Filters from standard mode are loaded Builtin jinja filters are enabled if not overridden by the above filters See: https://jinja.palletsprojects.com/en/3.0.x/templates/?highlight=builtin%20filters#builtin-filters ifelse : See: https://pwwang.github.io/liquidpy/api/liquid.filters.wild/ map() It is overridden by python's builtins.map() . To use the one from liquid , try liquid_map()","title":"Filters"},{"location":"wild/#tests","text":"All jinja tests are supported See: https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-tests","title":"Tests"},{"location":"wild/#tags","text":"liquidpy wild mode supports a set of tags that we can do arbitrary things.","title":"Tags"},{"location":"wild/#python-tag","text":"The python tag allows you to execute arbitrary code inside a template. It supports single line mode and block mode. If you just want execute a single line of python code: {% python a = 1 %} Or if you want to execute a chunk of code: {% python %} def func(x) ... b = func(a) {% endpython %} Note The python tag can only interact with the global variables. The variables in the context ( Context.vars ) cannot be referred and will not be affected. In the above examples, the first will write variable a the environment.globals or overwrite it. The second will use variable a in environment.globals and then write b to it. Tip Any variables declared at top level of the code gets stored in the environment.globals . If you don't want some to be stored, you should delete them using del Tip The code will be dedentated using textwrap.dedent and then send to exec . So: {% python %} [space][space]a [space][space]b {% endpython %} works as expected. But you can also write it like this: {% python %} [space][space]a [space][space]b {% endpython %} The first non-spaced line will be ignored. Tip You can also print stuff inside the code, which will be parsed as literals.","title":"python tag"},{"location":"wild/#import_-and-from_-tags","text":"The import_ and from_ tags help users to import python modules into the environment.globals . It works the same as python's import and from ... import ... Note The import and from from jinja are kept and work as they are in jinja.","title":"import_ and from_ tags"},{"location":"wild/#addfilter-tag","text":"This allows one to add a filter using python code. For example: {% addfilter trunc %} def trunc(string, n): return string[:n] {% endaddfilter %} {{ a | trunc : 3 }} When render with a=\"abcde\" , it gives: 'abc' Like the python tag, you can only use the variables in environment.globals inside the code. But unlike the python tag, anything you print inside the code will be ignored. You can also define a filter with the environment: {% addfilter render pass_env %} def render(env, expr, **kwargs): compiled = env.compile_expression(expr) return compiled(**kwargs) {% endaddfilter %} {{ \" item | plus(1)\" | render : a }} When render with a=1 , it gives 2 . Note The expresison passed to env.compile_expression() has to use the jinja-supported syntax (i.e. using colon to separate filter and its arguments is not supported). This is useful when you want to render an template expression insdie the template.","title":"addfilter tag"},{"location":"wild/#extensions","text":"jinja2.ext.debug is enabled","title":"Extensions"},{"location":"api/liquid.defaults/","text":"module liquid . defaults </> Provide default settings/values","title":"liquid.defaults"},{"location":"api/liquid.defaults/#liquiddefaults","text":"</> Provide default settings/values","title":"liquid.defaults"},{"location":"api/liquid.exts.ext/","text":"module liquid.exts . ext </> Provides a base extension class Classes LiquidExtension \u2014 A base extension class for extensions in this package to extend </> class liquid.exts.ext . LiquidExtension ( environment ) </> Bases jinja2.ext.Extension A base extension class for extensions in this package to extend Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Union(tokenstream, iterable of token)) \u2014 It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method filter_stream ( stream ) \u2192 Union(tokenstream, iterable of token) </> It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod __init_subclass__ ( ) </> Initalize the tags and raw_tags using tag manager method preprocess ( source , name , filename ) \u2192 str </> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method parse ( parser ) \u2192 Node </> Let tag manager to parse the tags that are being listened to","title":"liquid.exts.ext"},{"location":"api/liquid.exts.ext/#liquidextsext","text":"</> Provides a base extension class Classes LiquidExtension \u2014 A base extension class for extensions in this package to extend </> class","title":"liquid.exts.ext"},{"location":"api/liquid.exts.ext/#liquidextsextliquidextension","text":"</> Bases jinja2.ext.Extension A base extension class for extensions in this package to extend Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Union(tokenstream, iterable of token)) \u2014 It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method","title":"liquid.exts.ext.LiquidExtension"},{"location":"api/liquid.exts.ext/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.ext/#jinja2extextensionfilter_stream","text":"</> It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . method","title":"jinja2.ext.Extension.filter_stream"},{"location":"api/liquid.exts.ext/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.ext/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.ext/#liquidextsextliquidextensioninit_subclass","text":"</> Initalize the tags and raw_tags using tag manager method","title":"liquid.exts.ext.LiquidExtension.init_subclass"},{"location":"api/liquid.exts.ext/#liquidextsextliquidextensionpreprocess","text":"</> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method","title":"liquid.exts.ext.LiquidExtension.preprocess"},{"location":"api/liquid.exts.ext/#liquidextsextliquidextensionparse","text":"</> Let tag manager to parse the tags that are being listened to","title":"liquid.exts.ext.LiquidExtension.parse"},{"location":"api/liquid.exts.filter_colon/","text":"module liquid.exts . filter_colon </> Provides an extension to use colon to separate filter and its arguments Jinja uses {{a | filter(arg)}} , but liquid uses {{a | filter: arg}} Classes FilterColonExtension \u2014 This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters </> class liquid.exts.filter_colon . FilterColonExtension ( environment ) </> Bases jinja2.ext.Extension This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters Methods __init_subclass__ ( ) \u2014 This method is called when a class is subclassed. </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Token) \u2014 Modify the colon to lparen and rparen tokens </> parse ( parser ) (Union(node, list of node)) \u2014 If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. </> preprocess ( source , name , filename ) (str) \u2014 This method is called before the actual lexing and can be used topreprocess the source. The filename is optional. The return value must be the preprocessed source. </> classmethod __init_subclass__ ( ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method preprocess ( source , name , filename=None ) \u2192 str </> This method is called before the actual lexing and can be used topreprocess the source. The filename is optional. The return value must be the preprocessed source. method parse ( parser ) \u2192 Union(node, list of node) </> If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . generator filter_stream ( stream ) \u2192 Token </> Modify the colon to lparen and rparen tokens","title":"liquid.exts.filter_colon"},{"location":"api/liquid.exts.filter_colon/#liquidextsfilter_colon","text":"</> Provides an extension to use colon to separate filter and its arguments Jinja uses {{a | filter(arg)}} , but liquid uses {{a | filter: arg}} Classes FilterColonExtension \u2014 This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters </> class","title":"liquid.exts.filter_colon"},{"location":"api/liquid.exts.filter_colon/#liquidextsfilter_colonfiltercolonextension","text":"</> Bases jinja2.ext.Extension This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters Methods __init_subclass__ ( ) \u2014 This method is called when a class is subclassed. </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Token) \u2014 Modify the colon to lparen and rparen tokens </> parse ( parser ) (Union(node, list of node)) \u2014 If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. </> preprocess ( source , name , filename ) (str) \u2014 This method is called before the actual lexing and can be used topreprocess the source. The filename is optional. The return value must be the preprocessed source. </> classmethod","title":"liquid.exts.filter_colon.FilterColonExtension"},{"location":"api/liquid.exts.filter_colon/#jinja2extextensioninit_subclass","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method","title":"jinja2.ext.Extension.init_subclass"},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionpreprocess","text":"</> This method is called before the actual lexing and can be used topreprocess the source. The filename is optional. The return value must be the preprocessed source. method","title":"jinja2.ext.Extension.preprocess"},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionparse","text":"</> If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. method","title":"jinja2.ext.Extension.parse"},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.filter_colon/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . generator","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.filter_colon/#liquidextsfilter_colonfiltercolonextensionfilter_stream","text":"</> Modify the colon to lparen and rparen tokens","title":"liquid.exts.filter_colon.FilterColonExtension.filter_stream"},{"location":"api/liquid.exts.front_matter/","text":"module liquid.exts . front_matter </> Provides an extension to allow front matter in the template Classes FrontMatterExtension \u2014 This extension allows to have front matter </> class liquid.exts.front_matter . FrontMatterExtension ( environment ) </> Bases jinja2.ext.Extension This extension allows to have front matter Methods __init_subclass__ ( ) \u2014 This method is called when a class is subclassed. </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Union(tokenstream, iterable of token)) \u2014 It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . </> parse ( parser ) (Union(node, list of node)) \u2014 If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. </> preprocess ( source , name , filename ) (str) \u2014 Preprocess sourcee to extract front matter </> classmethod __init_subclass__ ( ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method filter_stream ( stream ) \u2192 Union(tokenstream, iterable of token) </> It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . method parse ( parser ) \u2192 Union(node, list of node) </> If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . method preprocess ( source , name , filename=None ) \u2192 str </> Preprocess sourcee to extract front matter","title":"liquid.exts.front_matter"},{"location":"api/liquid.exts.front_matter/#liquidextsfront_matter","text":"</> Provides an extension to allow front matter in the template Classes FrontMatterExtension \u2014 This extension allows to have front matter </> class","title":"liquid.exts.front_matter"},{"location":"api/liquid.exts.front_matter/#liquidextsfront_matterfrontmatterextension","text":"</> Bases jinja2.ext.Extension This extension allows to have front matter Methods __init_subclass__ ( ) \u2014 This method is called when a class is subclassed. </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Union(tokenstream, iterable of token)) \u2014 It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . </> parse ( parser ) (Union(node, list of node)) \u2014 If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. </> preprocess ( source , name , filename ) (str) \u2014 Preprocess sourcee to extract front matter </> classmethod","title":"liquid.exts.front_matter.FrontMatterExtension"},{"location":"api/liquid.exts.front_matter/#jinja2extextensioninit_subclass","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method","title":"jinja2.ext.Extension.init_subclass"},{"location":"api/liquid.exts.front_matter/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.front_matter/#jinja2extextensionfilter_stream","text":"</> It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . method","title":"jinja2.ext.Extension.filter_stream"},{"location":"api/liquid.exts.front_matter/#jinja2extextensionparse","text":"</> If any of the :attr: tags matched this method is called with theparser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes. method","title":"jinja2.ext.Extension.parse"},{"location":"api/liquid.exts.front_matter/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.front_matter/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . method","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.front_matter/#liquidextsfront_matterfrontmatterextensionpreprocess","text":"</> Preprocess sourcee to extract front matter","title":"liquid.exts.front_matter.FrontMatterExtension.preprocess"},{"location":"api/liquid.exts.jekyll/","text":"module liquid.exts . jekyll </> Extension for jekyll mode Classes LiquidJekyllExtension \u2014 Extension for jekyll mode </> class liquid.exts.jekyll . LiquidJekyllExtension ( environment ) </> Bases liquid.exts.standard.LiquidStandardExtension liquid.exts.ext.LiquidExtension jinja2.ext.Extension Extension for jekyll mode Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) \u2014 Supports for liquid features </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod __init_subclass__ ( ) </> Initalize the tags and raw_tags using tag manager method preprocess ( source , name , filename ) \u2192 str </> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method parse ( parser ) \u2192 Node </> Let tag manager to parse the tags that are being listened to generator filter_stream ( stream ) </> Supports for liquid features","title":"liquid.exts.jekyll"},{"location":"api/liquid.exts.jekyll/#liquidextsjekyll","text":"</> Extension for jekyll mode Classes LiquidJekyllExtension \u2014 Extension for jekyll mode </> class","title":"liquid.exts.jekyll"},{"location":"api/liquid.exts.jekyll/#liquidextsjekyllliquidjekyllextension","text":"</> Bases liquid.exts.standard.LiquidStandardExtension liquid.exts.ext.LiquidExtension jinja2.ext.Extension Extension for jekyll mode Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) \u2014 Supports for liquid features </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method","title":"liquid.exts.jekyll.LiquidJekyllExtension"},{"location":"api/liquid.exts.jekyll/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.jekyll/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.jekyll/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.jekyll/#liquidextsextliquidextensioninit_subclass","text":"</> Initalize the tags and raw_tags using tag manager method","title":"liquid.exts.ext.LiquidExtension.init_subclass"},{"location":"api/liquid.exts.jekyll/#liquidextsextliquidextensionpreprocess","text":"</> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method","title":"liquid.exts.ext.LiquidExtension.preprocess"},{"location":"api/liquid.exts.jekyll/#liquidextsextliquidextensionparse","text":"</> Let tag manager to parse the tags that are being listened to generator","title":"liquid.exts.ext.LiquidExtension.parse"},{"location":"api/liquid.exts.jekyll/#liquidextsstandardliquidstandardextensionfilter_stream","text":"</> Supports for liquid features","title":"liquid.exts.standard.LiquidStandardExtension.filter_stream"},{"location":"api/liquid.exts/","text":"package liquid . exts </> module liquid.exts . standard </> Provides an extension to implment features for standard liquid Classes LiquidStandardExtension \u2014 This extension implement features for standard liqiud </> module liquid.exts . ext </> Provides a base extension class Classes LiquidExtension \u2014 A base extension class for extensions in this package to extend </> module liquid.exts . jekyll </> Extension for jekyll mode Classes LiquidJekyllExtension \u2014 Extension for jekyll mode </> module liquid.exts . front_matter </> Provides an extension to allow front matter in the template Classes FrontMatterExtension \u2014 This extension allows to have front matter </> module liquid.exts . shopify </> Extension for shopify mode Classes LiquidShopifyExtension \u2014 Extension for jekyll mode </> module liquid.exts . wild </> Provides extension for wild mode Classes LiquidWildExtension \u2014 Extension for wild mode </> module liquid.exts . filter_colon </> Provides an extension to use colon to separate filter and its arguments Jinja uses {{a | filter(arg)}} , but liquid uses {{a | filter: arg}} Classes FilterColonExtension \u2014 This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters </>","title":"liquid.exts"},{"location":"api/liquid.exts/#liquidexts","text":"</> module","title":"liquid.exts"},{"location":"api/liquid.exts/#liquidextsstandard","text":"</> Provides an extension to implment features for standard liquid Classes LiquidStandardExtension \u2014 This extension implement features for standard liqiud </> module","title":"liquid.exts.standard"},{"location":"api/liquid.exts/#liquidextsext","text":"</> Provides a base extension class Classes LiquidExtension \u2014 A base extension class for extensions in this package to extend </> module","title":"liquid.exts.ext"},{"location":"api/liquid.exts/#liquidextsjekyll","text":"</> Extension for jekyll mode Classes LiquidJekyllExtension \u2014 Extension for jekyll mode </> module","title":"liquid.exts.jekyll"},{"location":"api/liquid.exts/#liquidextsfront_matter","text":"</> Provides an extension to allow front matter in the template Classes FrontMatterExtension \u2014 This extension allows to have front matter </> module","title":"liquid.exts.front_matter"},{"location":"api/liquid.exts/#liquidextsshopify","text":"</> Extension for shopify mode Classes LiquidShopifyExtension \u2014 Extension for jekyll mode </> module","title":"liquid.exts.shopify"},{"location":"api/liquid.exts/#liquidextswild","text":"</> Provides extension for wild mode Classes LiquidWildExtension \u2014 Extension for wild mode </> module","title":"liquid.exts.wild"},{"location":"api/liquid.exts/#liquidextsfilter_colon","text":"</> Provides an extension to use colon to separate filter and its arguments Jinja uses {{a | filter(arg)}} , but liquid uses {{a | filter: arg}} Classes FilterColonExtension \u2014 This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters </>","title":"liquid.exts.filter_colon"},{"location":"api/liquid.exts.shopify/","text":"module liquid.exts . shopify </> Extension for shopify mode Classes LiquidShopifyExtension \u2014 Extension for jekyll mode </> class liquid.exts.shopify . LiquidShopifyExtension ( environment ) </> Bases liquid.exts.standard.LiquidStandardExtension liquid.exts.ext.LiquidExtension jinja2.ext.Extension Extension for jekyll mode Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) \u2014 Supports for liquid features </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod __init_subclass__ ( ) </> Initalize the tags and raw_tags using tag manager method preprocess ( source , name , filename ) \u2192 str </> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method parse ( parser ) \u2192 Node </> Let tag manager to parse the tags that are being listened to generator filter_stream ( stream ) </> Supports for liquid features","title":"liquid.exts.shopify"},{"location":"api/liquid.exts.shopify/#liquidextsshopify","text":"</> Extension for shopify mode Classes LiquidShopifyExtension \u2014 Extension for jekyll mode </> class","title":"liquid.exts.shopify"},{"location":"api/liquid.exts.shopify/#liquidextsshopifyliquidshopifyextension","text":"</> Bases liquid.exts.standard.LiquidStandardExtension liquid.exts.ext.LiquidExtension jinja2.ext.Extension Extension for jekyll mode Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) \u2014 Supports for liquid features </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method","title":"liquid.exts.shopify.LiquidShopifyExtension"},{"location":"api/liquid.exts.shopify/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.shopify/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.shopify/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.shopify/#liquidextsextliquidextensioninit_subclass","text":"</> Initalize the tags and raw_tags using tag manager method","title":"liquid.exts.ext.LiquidExtension.init_subclass"},{"location":"api/liquid.exts.shopify/#liquidextsextliquidextensionpreprocess","text":"</> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method","title":"liquid.exts.ext.LiquidExtension.preprocess"},{"location":"api/liquid.exts.shopify/#liquidextsextliquidextensionparse","text":"</> Let tag manager to parse the tags that are being listened to generator","title":"liquid.exts.ext.LiquidExtension.parse"},{"location":"api/liquid.exts.shopify/#liquidextsstandardliquidstandardextensionfilter_stream","text":"</> Supports for liquid features","title":"liquid.exts.standard.LiquidStandardExtension.filter_stream"},{"location":"api/liquid.exts.standard/","text":"module liquid.exts . standard </> Provides an extension to implment features for standard liquid Classes LiquidStandardExtension \u2014 This extension implement features for standard liqiud </> class liquid.exts.standard . LiquidStandardExtension ( environment ) </> Bases liquid.exts.ext.LiquidExtension jinja2.ext.Extension This extension implement features for standard liqiud These features (that jinja does support) including 1. Allow '.size' to get length of an array (by replacing it with '. len ()') 2. Allow 'contains' to work as an operator by turning it into a test 3. Turn 'forloop' to 'loop' 4. Allow (1..5) , which will be turned to range(1, 6) Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) \u2014 Supports for liquid features </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod __init_subclass__ ( ) </> Initalize the tags and raw_tags using tag manager method preprocess ( source , name , filename ) \u2192 str </> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method parse ( parser ) \u2192 Node </> Let tag manager to parse the tags that are being listened to generator filter_stream ( stream ) </> Supports for liquid features","title":"liquid.exts.standard"},{"location":"api/liquid.exts.standard/#liquidextsstandard","text":"</> Provides an extension to implment features for standard liquid Classes LiquidStandardExtension \u2014 This extension implement features for standard liqiud </> class","title":"liquid.exts.standard"},{"location":"api/liquid.exts.standard/#liquidextsstandardliquidstandardextension","text":"</> Bases liquid.exts.ext.LiquidExtension jinja2.ext.Extension This extension implement features for standard liqiud These features (that jinja does support) including 1. Allow '.size' to get length of an array (by replacing it with '. len ()') 2. Allow 'contains' to work as an operator by turning it into a test 3. Turn 'forloop' to 'loop' 4. Allow (1..5) , which will be turned to range(1, 6) Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) \u2014 Supports for liquid features </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method","title":"liquid.exts.standard.LiquidStandardExtension"},{"location":"api/liquid.exts.standard/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.standard/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.standard/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.standard/#liquidextsextliquidextensioninit_subclass","text":"</> Initalize the tags and raw_tags using tag manager method","title":"liquid.exts.ext.LiquidExtension.init_subclass"},{"location":"api/liquid.exts.standard/#liquidextsextliquidextensionpreprocess","text":"</> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method","title":"liquid.exts.ext.LiquidExtension.preprocess"},{"location":"api/liquid.exts.standard/#liquidextsextliquidextensionparse","text":"</> Let tag manager to parse the tags that are being listened to generator","title":"liquid.exts.ext.LiquidExtension.parse"},{"location":"api/liquid.exts.standard/#liquidextsstandardliquidstandardextensionfilter_stream","text":"</> Supports for liquid features","title":"liquid.exts.standard.LiquidStandardExtension.filter_stream"},{"location":"api/liquid.exts.wild/","text":"module liquid.exts . wild </> Provides extension for wild mode Classes LiquidWildExtension \u2014 Extension for wild mode </> class liquid.exts.wild . LiquidWildExtension ( environment ) </> Bases liquid.exts.ext.LiquidExtension jinja2.ext.Extension Extension for wild mode Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Union(tokenstream, iterable of token)) \u2014 It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method bind ( environment ) \u2192 Extension </> Create a copy of this extension bound to another environment. method filter_stream ( stream ) \u2192 Union(tokenstream, iterable of token) </> It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . method attr ( name , lineno=None ) \u2192 ExtensionAttribute </> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method call_method ( name , args=None , kwargs=None , dyn_args=None , dyn_kwargs=None , lineno=None ) \u2192 Call </> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod __init_subclass__ ( ) </> Initalize the tags and raw_tags using tag manager method preprocess ( source , name , filename ) \u2192 str </> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method parse ( parser ) \u2192 Node </> Let tag manager to parse the tags that are being listened to","title":"liquid.exts.wild"},{"location":"api/liquid.exts.wild/#liquidextswild","text":"</> Provides extension for wild mode Classes LiquidWildExtension \u2014 Extension for wild mode </> class","title":"liquid.exts.wild"},{"location":"api/liquid.exts.wild/#liquidextswildliquidwildextension","text":"</> Bases liquid.exts.ext.LiquidExtension jinja2.ext.Extension Extension for wild mode Methods __init_subclass__ ( ) \u2014 Initalize the tags and raw_tags using tag manager </> attr ( name , lineno ) (ExtensionAttribute) \u2014 Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. </> bind ( environment ) (Extension) \u2014 Create a copy of this extension bound to another environment. </> call_method ( name , args , kwargs , dyn_args , dyn_kwargs , lineno ) (Call) \u2014 Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . </> filter_stream ( stream ) (Union(tokenstream, iterable of token)) \u2014 It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . </> parse ( parser ) (Node) \u2014 Let tag manager to parse the tags that are being listened to </> preprocess ( source , name , filename ) (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. </> method","title":"liquid.exts.wild.LiquidWildExtension"},{"location":"api/liquid.exts.wild/#jinja2extextensionbind","text":"</> Create a copy of this extension bound to another environment. method","title":"jinja2.ext.Extension.bind"},{"location":"api/liquid.exts.wild/#jinja2extextensionfilter_stream","text":"</> It's passed a :class: ~jinja2.lexer.TokenStream that can be usedto filter tokens returned. This method has to return an iterable of :class: ~jinja2.lexer.Token \\s, but it doesn't have to return a :class: ~jinja2.lexer.TokenStream . method","title":"jinja2.ext.Extension.filter_stream"},{"location":"api/liquid.exts.wild/#jinja2extextensionattr","text":"</> Return an attribute node for the current extension. This is usefulto pass constants on extensions to generated template code. :: self.attr('_my_attribute', lineno=lineno) method","title":"jinja2.ext.Extension.attr"},{"location":"api/liquid.exts.wild/#jinja2extextensioncall_method","text":"</> Call a method of the extension. This is a shortcut for:meth: attr + :class: jinja2.nodes.Call . classmethod","title":"jinja2.ext.Extension.call_method"},{"location":"api/liquid.exts.wild/#liquidextsextliquidextensioninit_subclass","text":"</> Initalize the tags and raw_tags using tag manager method","title":"liquid.exts.ext.LiquidExtension.init_subclass"},{"location":"api/liquid.exts.wild/#liquidextsextliquidextensionpreprocess","text":"</> Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. method","title":"liquid.exts.ext.LiquidExtension.preprocess"},{"location":"api/liquid.exts.wild/#liquidextsextliquidextensionparse","text":"</> Let tag manager to parse the tags that are being listened to","title":"liquid.exts.ext.LiquidExtension.parse"},{"location":"api/liquid.filters.jekyll/","text":"module liquid.filters . jekyll </> Provides jekyll filtersSee: https://jekyllrb.com/docs/liquid/filters/ Functions absolute_url ( env , value ) \u2014 Get absolute url based on site.baseurl </> array_to_sentence_string ( array , connector ) (str) \u2014 Join an array of things into a string by separating with commas and theword \"and\" for the last one. </> cgi_escape ( input ) (str) \u2014 CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. </> date_to_xmlschema ( env , value ) \u2014 Convert date to xml schema format </> find ( value , attr , query ) \u2014 Find elements from array using attribute value </> find_exp ( env , value , item , expr ) \u2014 Find elements using expression </> group_by_expr ( env , value , item , expr ) \u2014 Group by data using expression </> jekyll_slugify ( input , mode ) (str) \u2014 Slugify a string </> jekyll_sort ( array , prop , none_pos ) \u2014 Sort an array in a reverse way by default. </> jsonify ( input ) (str) \u2014 Convert the input into json string </> markdownify ( value ) \u2014 Markdownify a string </> normalize_whitespace ( value ) \u2014 Replace multiple spaces into one </> number_of_words ( input , mode ) (int) \u2014 Count the number of words in the input string. </> relative_url ( env , value ) \u2014 Get relative url based on site.baseurl </> sample ( value , n ) \u2014 Sample elements from array </> uri_escape ( input ) (str) \u2014 URI escape a string. </> where_exp ( env , value , item , expr ) \u2014 Where using expression </> xml_escape ( input ) (str) \u2014 Convert an object into its String representation </> function liquid.filters.jekyll . relative_url ( env , value ) </> Get relative url based on site.baseurl function liquid.filters.jekyll . absolute_url ( env , value ) </> Get absolute url based on site.baseurl function liquid.filters.jekyll . date_to_xmlschema ( env , value ) </> Convert date to xml schema format function liquid.filters.jekyll . where_exp ( env , value , item , expr ) </> Where using expression function liquid.filters.jekyll . find ( value , attr , query ) </> Find elements from array using attribute value function liquid.filters.jekyll . find_exp ( env , value , item , expr ) </> Find elements using expression function liquid.filters.jekyll . group_by_expr ( env , value , item , expr ) </> Group by data using expression function liquid.filters.jekyll . xml_escape ( input ) </> Convert an object into its String representation Parameters input (str) \u2014 The object to be converted Returns (str) The converted string function liquid.filters.jekyll . cgi_escape ( input ) </> CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. Parameters input (str) \u2014 The string to escape Returns (str) The escaped string function liquid.filters.jekyll . uri_escape ( input ) </> URI escape a string. Parameters input (str) \u2014 The string to escape Returns (str) The escaped string function liquid.filters.jekyll . jsonify ( input ) </> Convert the input into json string Parameters input (any) \u2014 The Array or Hash to be converted Returns (str) The converted json string function liquid.filters.jekyll . array_to_sentence_string ( array , connector='and' ) </> Join an array of things into a string by separating with commas and theword \"and\" for the last one. Parameters array (sequence of str) \u2014 The Array of Strings to join. connector (str, optional) \u2014 Word used to connect the last 2 items in the array Returns (str) The formatted string. function liquid.filters.jekyll . jekyll_slugify ( input , mode='default' ) </> Slugify a string Note that non-ascii characters are always translated to ascii ones. Parameters input (str) \u2014 The input string mode (str, optional) \u2014 How string is slugified Returns (str) The slugified string function liquid.filters.jekyll . number_of_words ( input , mode=None ) </> Count the number of words in the input string. Parameters input (str) \u2014 The String on which to operate. mode (str, optional) \u2014 Passing 'cjk' as the argument will count every CJK characterdetected as one word irrespective of being separated by whitespace. Passing 'auto' (auto-detect) works similar to 'cjk' Returns (int) The word count. function liquid.filters.jekyll . markdownify ( value ) </> Markdownify a string function liquid.filters.jekyll . normalize_whitespace ( value ) </> Replace multiple spaces into one function liquid.filters.jekyll . jekyll_sort ( array , prop=None , none_pos='first' ) </> Sort an array in a reverse way by default. Note that the order might be different than it with ruby. For example, in python \"1abc\" > \"1\" , but it's not the case in jekyll. Also, it's always in reverse order for property values. Parameters array \u2014 The array prop (str, optional) \u2014 property name none_pos (str, optional) \u2014 None order (first or last). Returns The sorted array function liquid.filters.jekyll . sample ( value , n=1 ) </> Sample elements from array","title":"liquid.filters.jekyll"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyll","text":"</> Provides jekyll filtersSee: https://jekyllrb.com/docs/liquid/filters/ Functions absolute_url ( env , value ) \u2014 Get absolute url based on site.baseurl </> array_to_sentence_string ( array , connector ) (str) \u2014 Join an array of things into a string by separating with commas and theword \"and\" for the last one. </> cgi_escape ( input ) (str) \u2014 CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. </> date_to_xmlschema ( env , value ) \u2014 Convert date to xml schema format </> find ( value , attr , query ) \u2014 Find elements from array using attribute value </> find_exp ( env , value , item , expr ) \u2014 Find elements using expression </> group_by_expr ( env , value , item , expr ) \u2014 Group by data using expression </> jekyll_slugify ( input , mode ) (str) \u2014 Slugify a string </> jekyll_sort ( array , prop , none_pos ) \u2014 Sort an array in a reverse way by default. </> jsonify ( input ) (str) \u2014 Convert the input into json string </> markdownify ( value ) \u2014 Markdownify a string </> normalize_whitespace ( value ) \u2014 Replace multiple spaces into one </> number_of_words ( input , mode ) (int) \u2014 Count the number of words in the input string. </> relative_url ( env , value ) \u2014 Get relative url based on site.baseurl </> sample ( value , n ) \u2014 Sample elements from array </> uri_escape ( input ) (str) \u2014 URI escape a string. </> where_exp ( env , value , item , expr ) \u2014 Where using expression </> xml_escape ( input ) (str) \u2014 Convert an object into its String representation </> function","title":"liquid.filters.jekyll"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllrelative_url","text":"</> Get relative url based on site.baseurl function","title":"liquid.filters.jekyll.relative_url"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllabsolute_url","text":"</> Get absolute url based on site.baseurl function","title":"liquid.filters.jekyll.absolute_url"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylldate_to_xmlschema","text":"</> Convert date to xml schema format function","title":"liquid.filters.jekyll.date_to_xmlschema"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllwhere_exp","text":"</> Where using expression function","title":"liquid.filters.jekyll.where_exp"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllfind","text":"</> Find elements from array using attribute value function","title":"liquid.filters.jekyll.find"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllfind_exp","text":"</> Find elements using expression function","title":"liquid.filters.jekyll.find_exp"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllgroup_by_expr","text":"</> Group by data using expression function","title":"liquid.filters.jekyll.group_by_expr"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllxml_escape","text":"</> Convert an object into its String representation Parameters input (str) \u2014 The object to be converted Returns (str) The converted string function","title":"liquid.filters.jekyll.xml_escape"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllcgi_escape","text":"</> CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. Parameters input (str) \u2014 The string to escape Returns (str) The escaped string function","title":"liquid.filters.jekyll.cgi_escape"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylluri_escape","text":"</> URI escape a string. Parameters input (str) \u2014 The string to escape Returns (str) The escaped string function","title":"liquid.filters.jekyll.uri_escape"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylljsonify","text":"</> Convert the input into json string Parameters input (any) \u2014 The Array or Hash to be converted Returns (str) The converted json string function","title":"liquid.filters.jekyll.jsonify"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllarray_to_sentence_string","text":"</> Join an array of things into a string by separating with commas and theword \"and\" for the last one. Parameters array (sequence of str) \u2014 The Array of Strings to join. connector (str, optional) \u2014 Word used to connect the last 2 items in the array Returns (str) The formatted string. function","title":"liquid.filters.jekyll.array_to_sentence_string"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylljekyll_slugify","text":"</> Slugify a string Note that non-ascii characters are always translated to ascii ones. Parameters input (str) \u2014 The input string mode (str, optional) \u2014 How string is slugified Returns (str) The slugified string function","title":"liquid.filters.jekyll.jekyll_slugify"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllnumber_of_words","text":"</> Count the number of words in the input string. Parameters input (str) \u2014 The String on which to operate. mode (str, optional) \u2014 Passing 'cjk' as the argument will count every CJK characterdetected as one word irrespective of being separated by whitespace. Passing 'auto' (auto-detect) works similar to 'cjk' Returns (int) The word count. function","title":"liquid.filters.jekyll.number_of_words"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllmarkdownify","text":"</> Markdownify a string function","title":"liquid.filters.jekyll.markdownify"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllnormalize_whitespace","text":"</> Replace multiple spaces into one function","title":"liquid.filters.jekyll.normalize_whitespace"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylljekyll_sort","text":"</> Sort an array in a reverse way by default. Note that the order might be different than it with ruby. For example, in python \"1abc\" > \"1\" , but it's not the case in jekyll. Also, it's always in reverse order for property values. Parameters array \u2014 The array prop (str, optional) \u2014 property name none_pos (str, optional) \u2014 None order (first or last). Returns The sorted array function","title":"liquid.filters.jekyll.jekyll_sort"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllsample","text":"</> Sample elements from array","title":"liquid.filters.jekyll.sample"},{"location":"api/liquid.filters.manager/","text":"module liquid.filters . manager </> Provides filter manager Classes FilterManager \u2014 A manager for filters </> class liquid.filters.manager . FilterManager ( ) </> A manager for filters Attributes filters (dict(str: )) \u2014 a mapping of filter names to filters Methods register ( name_or_filter ) \u2014 Register a filter </> update_to_env ( env , overwrite ) \u2014 Update the filters to environment </> method register ( name_or_filter=None ) </> Register a filter This can be used as a decorator Examples >>> @filter_manager . register >>> def add ( a , b ): >>> return a + b >>> # register it with an alias: >>> @filter_manager . register ( 'addfunc' ) >>> def add ( a , b ): >>> return a + b Parameters name_or_filter (Union(str, sequence of str, ), optional) \u2014 The filter to registerif name is given, will be treated as alias Returns The registered function or the decorator method update_to_env ( env , overwrite=True ) </> Update the filters to environment Parameters env (Environment) \u2014 The environment to update these filters to overwrite (bool, optional) \u2014 Whether overwrite existing filters in the env?","title":"liquid.filters.manager"},{"location":"api/liquid.filters.manager/#liquidfiltersmanager","text":"</> Provides filter manager Classes FilterManager \u2014 A manager for filters </> class","title":"liquid.filters.manager"},{"location":"api/liquid.filters.manager/#liquidfiltersmanagerfiltermanager","text":"</> A manager for filters Attributes filters (dict(str: )) \u2014 a mapping of filter names to filters Methods register ( name_or_filter ) \u2014 Register a filter </> update_to_env ( env , overwrite ) \u2014 Update the filters to environment </> method","title":"liquid.filters.manager.FilterManager"},{"location":"api/liquid.filters.manager/#liquidfiltersmanagerfiltermanagerregister","text":"</> Register a filter This can be used as a decorator Examples >>> @filter_manager . register >>> def add ( a , b ): >>> return a + b >>> # register it with an alias: >>> @filter_manager . register ( 'addfunc' ) >>> def add ( a , b ): >>> return a + b Parameters name_or_filter (Union(str, sequence of str, ), optional) \u2014 The filter to registerif name is given, will be treated as alias Returns The registered function or the decorator method","title":"liquid.filters.manager.FilterManager.register"},{"location":"api/liquid.filters.manager/#liquidfiltersmanagerfiltermanagerupdate_to_env","text":"</> Update the filters to environment Parameters env (Environment) \u2014 The environment to update these filters to overwrite (bool, optional) \u2014 Whether overwrite existing filters in the env?","title":"liquid.filters.manager.FilterManager.update_to_env"},{"location":"api/liquid.filters/","text":"package liquid . filters </> module liquid.filters . standard </> Provides standard liquid filters Classes DateTime \u2014 Date time allows plus/minus operation </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> attr ( base , prop ) \u2014 Similar as __getattr__() but also works like ` getitem () </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft , allow_false ) \u2014 Return the deft value if base is not set.Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> floor ( base ) \u2014 Get the floor of a number </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> regex_replace ( base , regex , replace , case_sensitive , count ) (str) \u2014 Replace matching regex pattern </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a listIf the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> module liquid.filters . jekyll </> Provides jekyll filtersSee: https://jekyllrb.com/docs/liquid/filters/ Functions absolute_url ( env , value ) \u2014 Get absolute url based on site.baseurl </> array_to_sentence_string ( array , connector ) (str) \u2014 Join an array of things into a string by separating with commas and theword \"and\" for the last one. </> cgi_escape ( input ) (str) \u2014 CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. </> date_to_xmlschema ( env , value ) \u2014 Convert date to xml schema format </> find ( value , attr , query ) \u2014 Find elements from array using attribute value </> find_exp ( env , value , item , expr ) \u2014 Find elements using expression </> group_by_expr ( env , value , item , expr ) \u2014 Group by data using expression </> jekyll_slugify ( input , mode ) (str) \u2014 Slugify a string </> jekyll_sort ( array , prop , none_pos ) \u2014 Sort an array in a reverse way by default. </> jsonify ( input ) (str) \u2014 Convert the input into json string </> markdownify ( value ) \u2014 Markdownify a string </> normalize_whitespace ( value ) \u2014 Replace multiple spaces into one </> number_of_words ( input , mode ) (int) \u2014 Count the number of words in the input string. </> relative_url ( env , value ) \u2014 Get relative url based on site.baseurl </> sample ( value , n ) \u2014 Sample elements from array </> uri_escape ( input ) (str) \u2014 URI escape a string. </> where_exp ( env , value , item , expr ) \u2014 Where using expression </> xml_escape ( input ) (str) \u2014 Convert an object into its String representation </> module liquid.filters . shopify </> Provides shopify filters module liquid.filters . wild </> Provides some wild filters Functions ifelse ( env , value , test , test_args , true , true_args , false , false_args ) (any) \u2014 An if-else filter, implementing a tenary-like filter. </> module liquid.filters . manager </> Provides filter manager Classes FilterManager \u2014 A manager for filters </>","title":"liquid.filters"},{"location":"api/liquid.filters/#liquidfilters","text":"</> module","title":"liquid.filters"},{"location":"api/liquid.filters/#liquidfiltersstandard","text":"</> Provides standard liquid filters Classes DateTime \u2014 Date time allows plus/minus operation </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> attr ( base , prop ) \u2014 Similar as __getattr__() but also works like ` getitem () </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft , allow_false ) \u2014 Return the deft value if base is not set.Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> floor ( base ) \u2014 Get the floor of a number </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> regex_replace ( base , regex , replace , case_sensitive , count ) (str) \u2014 Replace matching regex pattern </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a listIf the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> module","title":"liquid.filters.standard"},{"location":"api/liquid.filters/#liquidfiltersjekyll","text":"</> Provides jekyll filtersSee: https://jekyllrb.com/docs/liquid/filters/ Functions absolute_url ( env , value ) \u2014 Get absolute url based on site.baseurl </> array_to_sentence_string ( array , connector ) (str) \u2014 Join an array of things into a string by separating with commas and theword \"and\" for the last one. </> cgi_escape ( input ) (str) \u2014 CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. </> date_to_xmlschema ( env , value ) \u2014 Convert date to xml schema format </> find ( value , attr , query ) \u2014 Find elements from array using attribute value </> find_exp ( env , value , item , expr ) \u2014 Find elements using expression </> group_by_expr ( env , value , item , expr ) \u2014 Group by data using expression </> jekyll_slugify ( input , mode ) (str) \u2014 Slugify a string </> jekyll_sort ( array , prop , none_pos ) \u2014 Sort an array in a reverse way by default. </> jsonify ( input ) (str) \u2014 Convert the input into json string </> markdownify ( value ) \u2014 Markdownify a string </> normalize_whitespace ( value ) \u2014 Replace multiple spaces into one </> number_of_words ( input , mode ) (int) \u2014 Count the number of words in the input string. </> relative_url ( env , value ) \u2014 Get relative url based on site.baseurl </> sample ( value , n ) \u2014 Sample elements from array </> uri_escape ( input ) (str) \u2014 URI escape a string. </> where_exp ( env , value , item , expr ) \u2014 Where using expression </> xml_escape ( input ) (str) \u2014 Convert an object into its String representation </> module","title":"liquid.filters.jekyll"},{"location":"api/liquid.filters/#liquidfiltersshopify","text":"</> Provides shopify filters module","title":"liquid.filters.shopify"},{"location":"api/liquid.filters/#liquidfilterswild","text":"</> Provides some wild filters Functions ifelse ( env , value , test , test_args , true , true_args , false , false_args ) (any) \u2014 An if-else filter, implementing a tenary-like filter. </> module","title":"liquid.filters.wild"},{"location":"api/liquid.filters/#liquidfiltersmanager","text":"</> Provides filter manager Classes FilterManager \u2014 A manager for filters </>","title":"liquid.filters.manager"},{"location":"api/liquid.filters.shopify/","text":"module liquid.filters . shopify </> Provides shopify filters","title":"liquid.filters.shopify"},{"location":"api/liquid.filters.shopify/#liquidfiltersshopify","text":"</> Provides shopify filters","title":"liquid.filters.shopify"},{"location":"api/liquid.filters.standard/","text":"module liquid.filters . standard </> Provides standard liquid filters Classes DateTime \u2014 Date time allows plus/minus operation </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> attr ( base , prop ) \u2014 Similar as __getattr__() but also works like ` getitem () </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft , allow_false ) \u2014 Return the deft value if base is not set.Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> floor ( base ) \u2014 Get the floor of a number </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> regex_replace ( base , regex , replace , case_sensitive , count ) (str) \u2014 Replace matching regex pattern </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a listIf the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> class liquid.filters.standard . DateTime ( dt , fmt ) </> Date time allows plus/minus operation Methods __str__ ( ) (str) \u2014 How it is rendered </> method __str__ ( ) \u2192 str </> How it is rendered class liquid.filters.standard . EmptyDrop ( ) </> The EmptyDrop class borrowed from liquid function liquid.filters.standard . split ( base , sep ) </> Split a string into a listIf the sep is empty, return the list of characters function liquid.filters.standard . append ( base , suffix ) </> Append a suffix to a string function liquid.filters.standard . prepend ( base , prefix ) </> Prepend a prefix to a string function liquid.filters.standard . times ( base , sep ) </> Implementation of * function liquid.filters.standard . minus ( base , sep ) </> Implementation of - function liquid.filters.standard . plus ( base , sep ) </> Implementation of + function liquid.filters.standard . modulo ( base , sep ) </> Implementation of % function liquid.filters.standard . ceil ( base ) </> Get the ceil of a number function liquid.filters.standard . floor ( base ) </> Get the floor of a number function liquid.filters.standard . liquid_date ( base , fmt ) </> Format a date/datetime function liquid.filters.standard . default ( base , deft , allow_false=False ) </> Return the deft value if base is not set.Otherwise, return base function liquid.filters.standard . divided_by ( base , dvdby ) </> Implementation of / or // function liquid.filters.standard . escape_once ( base ) </> Escapse html characters only once of the string function liquid.filters.standard . newline_to_br ( base ) </> Replace newline with <br /> function liquid.filters.standard . remove ( base , string ) </> Remove a substring from a string function liquid.filters.standard . remove_first ( base , string ) </> Remove the first substring from a string function liquid.filters.standard . replace_first ( base , old , new ) </> Replace the first substring with new string function liquid.filters.standard . sort ( base ) </> Get the sorted list function liquid.filters.standard . sort_natural ( base ) </> Get the sorted list in a case-insensitive manner function liquid.filters.standard . liquid_slice ( base , start , length=1 ) </> Slice a list function liquid.filters.standard . strip_html ( base ) </> Strip html tags from a string function liquid.filters.standard . strip_newlines ( base ) </> Strip newlines from a string function liquid.filters.standard . truncate ( base , length , ellipsis='...' ) </> Truncate a string function liquid.filters.standard . truncatewords ( base , length , ellipsis='...' ) </> Truncate a string by words function liquid.filters.standard . uniq ( base ) </> Get the unique elements from a list function liquid.filters.standard . url_decode ( base ) </> Url-decode a string function liquid.filters.standard . url_encode ( base ) </> Url-encode a string function liquid.filters.standard . where ( base , prop , value ) </> Query a list of objects with a given property value function liquid.filters.standard . liquid_map ( base , prop ) </> Map a property to a list of objects function liquid.filters.standard . attr ( base , prop ) </> Similar as __getattr__() but also works like ` getitem () function liquid.filters.standard . compact ( base ) </> Remove empties from a list function liquid.filters.standard . regex_replace ( base , regex , replace='' , case_sensitive=False , count=0 ) \u2192 str </> Replace matching regex pattern","title":"liquid.filters.standard"},{"location":"api/liquid.filters.standard/#liquidfiltersstandard","text":"</> Provides standard liquid filters Classes DateTime \u2014 Date time allows plus/minus operation </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> attr ( base , prop ) \u2014 Similar as __getattr__() but also works like ` getitem () </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft , allow_false ) \u2014 Return the deft value if base is not set.Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> floor ( base ) \u2014 Get the floor of a number </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> regex_replace ( base , regex , replace , case_sensitive , count ) (str) \u2014 Replace matching regex pattern </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a listIf the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> class","title":"liquid.filters.standard"},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddatetime","text":"</> Date time allows plus/minus operation Methods __str__ ( ) (str) \u2014 How it is rendered </> method","title":"liquid.filters.standard.DateTime"},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddatetimestr","text":"</> How it is rendered class","title":"liquid.filters.standard.DateTime.str"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardemptydrop","text":"</> The EmptyDrop class borrowed from liquid function","title":"liquid.filters.standard.EmptyDrop"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardsplit","text":"</> Split a string into a listIf the sep is empty, return the list of characters function","title":"liquid.filters.standard.split"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardappend","text":"</> Append a suffix to a string function","title":"liquid.filters.standard.append"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardprepend","text":"</> Prepend a prefix to a string function","title":"liquid.filters.standard.prepend"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardtimes","text":"</> Implementation of * function","title":"liquid.filters.standard.times"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardminus","text":"</> Implementation of - function","title":"liquid.filters.standard.minus"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardplus","text":"</> Implementation of + function","title":"liquid.filters.standard.plus"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardmodulo","text":"</> Implementation of % function","title":"liquid.filters.standard.modulo"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardceil","text":"</> Get the ceil of a number function","title":"liquid.filters.standard.ceil"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardfloor","text":"</> Get the floor of a number function","title":"liquid.filters.standard.floor"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardliquid_date","text":"</> Format a date/datetime function","title":"liquid.filters.standard.liquid_date"},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddefault","text":"</> Return the deft value if base is not set.Otherwise, return base function","title":"liquid.filters.standard.default"},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddivided_by","text":"</> Implementation of / or // function","title":"liquid.filters.standard.divided_by"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardescape_once","text":"</> Escapse html characters only once of the string function","title":"liquid.filters.standard.escape_once"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardnewline_to_br","text":"</> Replace newline with <br /> function","title":"liquid.filters.standard.newline_to_br"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardremove","text":"</> Remove a substring from a string function","title":"liquid.filters.standard.remove"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardremove_first","text":"</> Remove the first substring from a string function","title":"liquid.filters.standard.remove_first"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardreplace_first","text":"</> Replace the first substring with new string function","title":"liquid.filters.standard.replace_first"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardsort","text":"</> Get the sorted list function","title":"liquid.filters.standard.sort"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardsort_natural","text":"</> Get the sorted list in a case-insensitive manner function","title":"liquid.filters.standard.sort_natural"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardliquid_slice","text":"</> Slice a list function","title":"liquid.filters.standard.liquid_slice"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardstrip_html","text":"</> Strip html tags from a string function","title":"liquid.filters.standard.strip_html"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardstrip_newlines","text":"</> Strip newlines from a string function","title":"liquid.filters.standard.strip_newlines"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardtruncate","text":"</> Truncate a string function","title":"liquid.filters.standard.truncate"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardtruncatewords","text":"</> Truncate a string by words function","title":"liquid.filters.standard.truncatewords"},{"location":"api/liquid.filters.standard/#liquidfiltersstandarduniq","text":"</> Get the unique elements from a list function","title":"liquid.filters.standard.uniq"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardurl_decode","text":"</> Url-decode a string function","title":"liquid.filters.standard.url_decode"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardurl_encode","text":"</> Url-encode a string function","title":"liquid.filters.standard.url_encode"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardwhere","text":"</> Query a list of objects with a given property value function","title":"liquid.filters.standard.where"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardliquid_map","text":"</> Map a property to a list of objects function","title":"liquid.filters.standard.liquid_map"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardattr","text":"</> Similar as __getattr__() but also works like ` getitem () function","title":"liquid.filters.standard.attr"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardcompact","text":"</> Remove empties from a list function","title":"liquid.filters.standard.compact"},{"location":"api/liquid.filters.standard/#liquidfiltersstandardregex_replace","text":"</> Replace matching regex pattern","title":"liquid.filters.standard.regex_replace"},{"location":"api/liquid.filters.wild/","text":"module liquid.filters . wild </> Provides some wild filters Functions ifelse ( env , value , test , test_args , true , true_args , false , false_args ) (any) \u2014 An if-else filter, implementing a tenary-like filter. </> function liquid.filters.wild . ifelse ( env , value , test , test_args=() , true=None , true_args=() , false=None , false_args=() ) </> An if-else filter, implementing a tenary-like filter. Use ifelse or if_else . Examples >>> {{ a | ifelse : isinstance , ( int , ), >>> \"plus\" , ( 1 , ), >>> \"append\" , ( \".html\" , ) }} >>> # 2 when a = 1 >>> # \"a.html\" when a = \"a\" Parameters value (any) \u2014 The base value test (any) \u2014 The test callable or filter name test_args (any, optional) \u2014 Other args (value as the first arg) for the test true (any, optional) \u2014 The callable or filter name when test is True true_args (any, optional) \u2014 Other args (value as the first arg) for the trueWhen this is None, return the true callable itself or the name of the filter it self false (any, optional) \u2014 The callable or filter name when test is False false_args (any, optional) \u2014 Other args (value as the first arg) for the falseWhen this is None, return the false callable itself or the name of the filter it self Returns (any) The result of true of test result is True otherwise result of false.","title":"liquid.filters.wild"},{"location":"api/liquid.filters.wild/#liquidfilterswild","text":"</> Provides some wild filters Functions ifelse ( env , value , test , test_args , true , true_args , false , false_args ) (any) \u2014 An if-else filter, implementing a tenary-like filter. </> function","title":"liquid.filters.wild"},{"location":"api/liquid.filters.wild/#liquidfilterswildifelse","text":"</> An if-else filter, implementing a tenary-like filter. Use ifelse or if_else . Examples >>> {{ a | ifelse : isinstance , ( int , ), >>> \"plus\" , ( 1 , ), >>> \"append\" , ( \".html\" , ) }} >>> # 2 when a = 1 >>> # \"a.html\" when a = \"a\" Parameters value (any) \u2014 The base value test (any) \u2014 The test callable or filter name test_args (any, optional) \u2014 Other args (value as the first arg) for the test true (any, optional) \u2014 The callable or filter name when test is True true_args (any, optional) \u2014 Other args (value as the first arg) for the trueWhen this is None, return the true callable itself or the name of the filter it self false (any, optional) \u2014 The callable or filter name when test is False false_args (any, optional) \u2014 Other args (value as the first arg) for the falseWhen this is None, return the false callable itself or the name of the filter it self Returns (any) The result of true of test result is True otherwise result of false.","title":"liquid.filters.wild.ifelse"},{"location":"api/liquid.liquid/","text":"module liquid . liquid </> Provides Liquid class Classes Liquid \u2014 The entrance for the package </> class liquid.liquid . Liquid ( template , from_file=None , mode=None , env=None , filter_with_colon=None , search_paths=None , globals=None , filters=None , filters_as_globals=None , **kwargs ) </> The entrance for the package Examples >>> Liquid ( '{{a}}' , from_file = False ) >>> Liquid ( 'template.html' ) Parameters template (PathLike or str) \u2014 The template string or path of the template file from_file (bool, optional) \u2014 Whether template is a file path. If True, a FileSystemLoader will be used in the env . mode (str, optional) \u2014 The mode of the engine. - standard: Most compatibility with the standard liquid engine - jekyll: The jekyll-compatible mode - shopify: The shopify-compatible mode - wild: The liquid- and jinja-compatible mode env (Environment, optional) \u2014 The jinja environment filter_with_colon (bool, optional) \u2014 Whether enable to use colon to separate filter andits arguments (i.e. {{a | filter: arg}} ). If False, will fallback to use parentheses ( {{a | filter(arg)}} ) search_paths (Union(pathlike, str, iterable of pathlike or str), optional) \u2014 The search paths for the template files.This only supports specification of paths. If you need so specify encoding and/or followlinks , you should use jinja's FileSystemLoader globals (optional) \u2014 Additional global values to be used to render the template filters (optional) \u2014 Additional filters be to used to render the template filters_as_globals (bool, optional) \u2014 Whether also use filters as globalsOnly works in wild mode **kwargs (any) \u2014 Other arguments for an jinja Environment construction andconfigurations for extensions Methods from_env ( template , env , from_file , filter_with_colon , filters_as_globals , mode ) ( Liquid ) \u2014 Initiate a template from a jinja environment </> render ( *args , **kwargs ) (any) \u2014 Render the template. </> render_async ( *args , **kwargs ) (any) \u2014 Asynchronously render the template </> method render ( *args , **kwargs ) \u2192 any </> Render the template. You can either pass the values using tpl.render(a=1) or tpl.render({'a': 1}) method render_async ( *args , **kwargs ) \u2192 any </> Asynchronously render the template classmethod from_env ( template , env , from_file=None , filter_with_colon=None , filters_as_globals=None , mode=None ) \u2192 Liquid </> Initiate a template from a jinja environment You should not specify any liquid-related extensions here. They will be added automatically. No search path is allow to be passed here. Instead, use jinja2's loaders or use the constructor to initialize a template. @Args: template: The template string or path of the template file env: The jinja environment from_file: Whether template is a file path. If True, a FileSystemLoader will be used in the env . filter_with_colon: Whether enable to use colon to separate filter and its arguments (i.e. {{a | filter: arg}} ). If False, will fallback to use parentheses ( {{a | filter(arg)}} ) filters_as_globals: Whether also use filters as globals Only works in wild mode mode: The mode of the engine. - standard: Most compatibility with the standard liquid engine - wild: The liquid- and jinja-compatible mode - jekyll: The jekyll-compatible mode @Returns: A Liquid object","title":"liquid.liquid"},{"location":"api/liquid.liquid/#liquidliquid","text":"</> Provides Liquid class Classes Liquid \u2014 The entrance for the package </> class","title":"liquid.liquid"},{"location":"api/liquid.liquid/#liquidliquidliquid","text":"</> The entrance for the package Examples >>> Liquid ( '{{a}}' , from_file = False ) >>> Liquid ( 'template.html' ) Parameters template (PathLike or str) \u2014 The template string or path of the template file from_file (bool, optional) \u2014 Whether template is a file path. If True, a FileSystemLoader will be used in the env . mode (str, optional) \u2014 The mode of the engine. - standard: Most compatibility with the standard liquid engine - jekyll: The jekyll-compatible mode - shopify: The shopify-compatible mode - wild: The liquid- and jinja-compatible mode env (Environment, optional) \u2014 The jinja environment filter_with_colon (bool, optional) \u2014 Whether enable to use colon to separate filter andits arguments (i.e. {{a | filter: arg}} ). If False, will fallback to use parentheses ( {{a | filter(arg)}} ) search_paths (Union(pathlike, str, iterable of pathlike or str), optional) \u2014 The search paths for the template files.This only supports specification of paths. If you need so specify encoding and/or followlinks , you should use jinja's FileSystemLoader globals (optional) \u2014 Additional global values to be used to render the template filters (optional) \u2014 Additional filters be to used to render the template filters_as_globals (bool, optional) \u2014 Whether also use filters as globalsOnly works in wild mode **kwargs (any) \u2014 Other arguments for an jinja Environment construction andconfigurations for extensions Methods from_env ( template , env , from_file , filter_with_colon , filters_as_globals , mode ) ( Liquid ) \u2014 Initiate a template from a jinja environment </> render ( *args , **kwargs ) (any) \u2014 Render the template. </> render_async ( *args , **kwargs ) (any) \u2014 Asynchronously render the template </> method","title":"liquid.liquid.Liquid"},{"location":"api/liquid.liquid/#liquidliquidliquidrender","text":"</> Render the template. You can either pass the values using tpl.render(a=1) or tpl.render({'a': 1}) method","title":"liquid.liquid.Liquid.render"},{"location":"api/liquid.liquid/#liquidliquidliquidrender_async","text":"</> Asynchronously render the template classmethod","title":"liquid.liquid.Liquid.render_async"},{"location":"api/liquid.liquid/#liquidliquidliquidfrom_env","text":"</> Initiate a template from a jinja environment You should not specify any liquid-related extensions here. They will be added automatically. No search path is allow to be passed here. Instead, use jinja2's loaders or use the constructor to initialize a template. @Args: template: The template string or path of the template file env: The jinja environment from_file: Whether template is a file path. If True, a FileSystemLoader will be used in the env . filter_with_colon: Whether enable to use colon to separate filter and its arguments (i.e. {{a | filter: arg}} ). If False, will fallback to use parentheses ( {{a | filter(arg)}} ) filters_as_globals: Whether also use filters as globals Only works in wild mode mode: The mode of the engine. - standard: Most compatibility with the standard liquid engine - wild: The liquid- and jinja-compatible mode - jekyll: The jekyll-compatible mode @Returns: A Liquid object","title":"liquid.liquid.Liquid.from_env"},{"location":"api/liquid/","text":"package liquid </> A port of liquid template engine for python on the shoulders of jinja2 module liquid . patching </> Patch a couple of jinja functions to implement some featuresthat are impossible or too complex to be implemented by extensions Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for' Functions patch_jinja ( ) \u2014 Monkey-patch jinja </> unpatch_jinja ( ) \u2014 Restore the patches to jinja </> module liquid . liquid </> Provides Liquid class Classes Liquid \u2014 The entrance for the package </> module liquid . utils </> Some utils Functions parse_tag_args ( stream , name , lineno ) (Node) \u2014 Parse arguments for a tag. </> peek_tokens ( stream , n ) (list of Token) \u2014 Peek ahead 'n' tokens in the token stream, but don't move the cursor </> module liquid . defaults </> Provide default settings/values","title":"liquid"},{"location":"api/liquid/#liquid","text":"</> A port of liquid template engine for python on the shoulders of jinja2 module","title":"liquid"},{"location":"api/liquid/#liquidpatching","text":"</> Patch a couple of jinja functions to implement some featuresthat are impossible or too complex to be implemented by extensions Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for' Functions patch_jinja ( ) \u2014 Monkey-patch jinja </> unpatch_jinja ( ) \u2014 Restore the patches to jinja </> module","title":"liquid.patching"},{"location":"api/liquid/#liquidliquid","text":"</> Provides Liquid class Classes Liquid \u2014 The entrance for the package </> module","title":"liquid.liquid"},{"location":"api/liquid/#liquidutils","text":"</> Some utils Functions parse_tag_args ( stream , name , lineno ) (Node) \u2014 Parse arguments for a tag. </> peek_tokens ( stream , n ) (list of Token) \u2014 Peek ahead 'n' tokens in the token stream, but don't move the cursor </> module","title":"liquid.utils"},{"location":"api/liquid/#liquiddefaults","text":"</> Provide default settings/values","title":"liquid.defaults"},{"location":"api/liquid.patching/","text":"module liquid . patching </> Patch a couple of jinja functions to implement some featuresthat are impossible or too complex to be implemented by extensions Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for' Functions patch_jinja ( ) \u2014 Monkey-patch jinja </> unpatch_jinja ( ) \u2014 Restore the patches to jinja </> function liquid.patching . patch_jinja ( ) </> Monkey-patch jinja function liquid.patching . unpatch_jinja ( ) </> Restore the patches to jinja","title":"liquid.patching"},{"location":"api/liquid.patching/#liquidpatching","text":"</> Patch a couple of jinja functions to implement some featuresthat are impossible or too complex to be implemented by extensions Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for' Functions patch_jinja ( ) \u2014 Monkey-patch jinja </> unpatch_jinja ( ) \u2014 Restore the patches to jinja </> function","title":"liquid.patching"},{"location":"api/liquid.patching/#liquidpatchingpatch_jinja","text":"</> Monkey-patch jinja function","title":"liquid.patching.patch_jinja"},{"location":"api/liquid.patching/#liquidpatchingunpatch_jinja","text":"</> Restore the patches to jinja","title":"liquid.patching.unpatch_jinja"},{"location":"api/liquid.tags.jekyll/","text":"module liquid.tags . jekyll </> Provides jekyll tags Functions include_relative ( token , parser ) (Node) \u2014 The {% include_relative ... %} tag </> function liquid.tags.jekyll . include_relative ( token , parser ) \u2192 Node </> The {% include_relative ... %} tag","title":"liquid.tags.jekyll"},{"location":"api/liquid.tags.jekyll/#liquidtagsjekyll","text":"</> Provides jekyll tags Functions include_relative ( token , parser ) (Node) \u2014 The {% include_relative ... %} tag </> function","title":"liquid.tags.jekyll"},{"location":"api/liquid.tags.jekyll/#liquidtagsjekyllinclude_relative","text":"</> The {% include_relative ... %} tag","title":"liquid.tags.jekyll.include_relative"},{"location":"api/liquid.tags.manager/","text":"module liquid.tags . manager </> Provide tag manager Classes TagManager \u2014 A manager for tags </> Functions decode_raw ( body ) (str) \u2014 Decode the encoded string in body </> function liquid.tags.manager . decode_raw ( body ) </> Decode the encoded string in body The start string in body is encoded so that they won't be recognized as variable/comment/block by jinja. This way, we can protect the body from being tokenized. Parameters body (str) \u2014 The body Returns (str) The decoded string. class liquid.tags.manager . TagManager ( ) </> A manager for tags Attributes envs (dict(str: bool)) \u2014 a mapping of tag names and whether environment should be passedto the parser functions names (set of str) \u2014 Get a set of the tag names </> names_raw (set of str) \u2014 Get a set of names of tags whose body will be kept raw </> raws (dict(str: bool)) \u2014 a mapping of tag names and whether the tag body should bekept raw. tags (dict(str: )) \u2014 a mapping of tag names and parser functions Methods parse ( env , token , parser ) (Node) \u2014 Calling the parser functions to parse the tags </> register ( name_or_tagparser , env , raw ) \u2014 Register a filter </> method register ( name_or_tagparser=None , env=False , raw=False ) </> Register a filter This can be used as a decorator Examples >>> @tag_manager . register >>> def comment ( token , parser ): >>> from jinja2 import nodes >>> return nodes . Const ( \"\" ) Parameters name_or_tagparser (str or , optional) \u2014 The tag parser to registerif name is given, will be treated as alias env (bool, optional) \u2014 Whether we should pass environment to the parser raw (bool, optional) \u2014 Whether we should keep the body of the tag raw Returns The registered parser for the tag or a decorator method parse ( env , token , parser ) </> Calling the parser functions to parse the tags Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches the tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node","title":"liquid.tags.manager"},{"location":"api/liquid.tags.manager/#liquidtagsmanager","text":"</> Provide tag manager Classes TagManager \u2014 A manager for tags </> Functions decode_raw ( body ) (str) \u2014 Decode the encoded string in body </> function","title":"liquid.tags.manager"},{"location":"api/liquid.tags.manager/#liquidtagsmanagerdecode_raw","text":"</> Decode the encoded string in body The start string in body is encoded so that they won't be recognized as variable/comment/block by jinja. This way, we can protect the body from being tokenized. Parameters body (str) \u2014 The body Returns (str) The decoded string. class","title":"liquid.tags.manager.decode_raw"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanager","text":"</> A manager for tags Attributes envs (dict(str: bool)) \u2014 a mapping of tag names and whether environment should be passedto the parser functions names (set of str) \u2014 Get a set of the tag names </> names_raw (set of str) \u2014 Get a set of names of tags whose body will be kept raw </> raws (dict(str: bool)) \u2014 a mapping of tag names and whether the tag body should bekept raw. tags (dict(str: )) \u2014 a mapping of tag names and parser functions Methods parse ( env , token , parser ) (Node) \u2014 Calling the parser functions to parse the tags </> register ( name_or_tagparser , env , raw ) \u2014 Register a filter </> method","title":"liquid.tags.manager.TagManager"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerregister","text":"</> Register a filter This can be used as a decorator Examples >>> @tag_manager . register >>> def comment ( token , parser ): >>> from jinja2 import nodes >>> return nodes . Const ( \"\" ) Parameters name_or_tagparser (str or , optional) \u2014 The tag parser to registerif name is given, will be treated as alias env (bool, optional) \u2014 Whether we should pass environment to the parser raw (bool, optional) \u2014 Whether we should keep the body of the tag raw Returns The registered parser for the tag or a decorator method","title":"liquid.tags.manager.TagManager.register"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerparse","text":"</> Calling the parser functions to parse the tags Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches the tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node","title":"liquid.tags.manager.TagManager.parse"},{"location":"api/liquid.tags/","text":"package liquid . tags </> module liquid.tags . standard </> Provides standard liquid tags Functions assign ( token , parser ) (Node) \u2014 The assign tag {% assign x = ... %} </> capture ( token , parser ) (Node) \u2014 The capture tag {% capture var %}...{% endcapture %} </> case ( token , parser ) (Node) \u2014 The case-when tag {% case x %}{% when y %} ... {% endcase %} </> comment ( token , parser ) (Node) \u2014 The comment tag {% comment %} ... {% endcomment %} </> cycle ( token , parser ) (Node) \u2014 The cycle tag {% cycle ... %} </> decrement ( token , parser ) (list of Node) \u2014 The decrement tag {% decrement x %} </> increment ( token , parser ) (list of Node) \u2014 The increment tag {% increment x %} </> tablerow ( token , parser ) (Union(node, list of node)) \u2014 The tablerow tag {% tablerow ... %} ... {% endtablerow %} </> unless ( token , parser ) (Node) \u2014 The unless tag {% unless ... %} ... {% endunless %} </> module liquid.tags . jekyll </> Provides jekyll tags Functions include_relative ( token , parser ) (Node) \u2014 The {% include_relative ... %} tag </> module liquid.tags . shopify </> Provide shopify tagssee: https://shopify.dev/api/liquid/tags module liquid.tags . wild </> Provides tags for wild mode Functions addfilter ( env , token , parser ) (Node) \u2014 The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} </> from_ ( env , token , parser ) (Node) \u2014 The from_ tag {% from_ ... %} </> import_ ( env , token , parser ) (Node) \u2014 The import_ tag {% import_ ... %} </> python ( env , token , parser ) (Node) \u2014 The python tag </> module liquid.tags . manager </> Provide tag manager Classes TagManager \u2014 A manager for tags </> Functions decode_raw ( body ) (str) \u2014 Decode the encoded string in body </>","title":"liquid.tags"},{"location":"api/liquid.tags/#liquidtags","text":"</> module","title":"liquid.tags"},{"location":"api/liquid.tags/#liquidtagsstandard","text":"</> Provides standard liquid tags Functions assign ( token , parser ) (Node) \u2014 The assign tag {% assign x = ... %} </> capture ( token , parser ) (Node) \u2014 The capture tag {% capture var %}...{% endcapture %} </> case ( token , parser ) (Node) \u2014 The case-when tag {% case x %}{% when y %} ... {% endcase %} </> comment ( token , parser ) (Node) \u2014 The comment tag {% comment %} ... {% endcomment %} </> cycle ( token , parser ) (Node) \u2014 The cycle tag {% cycle ... %} </> decrement ( token , parser ) (list of Node) \u2014 The decrement tag {% decrement x %} </> increment ( token , parser ) (list of Node) \u2014 The increment tag {% increment x %} </> tablerow ( token , parser ) (Union(node, list of node)) \u2014 The tablerow tag {% tablerow ... %} ... {% endtablerow %} </> unless ( token , parser ) (Node) \u2014 The unless tag {% unless ... %} ... {% endunless %} </> module","title":"liquid.tags.standard"},{"location":"api/liquid.tags/#liquidtagsjekyll","text":"</> Provides jekyll tags Functions include_relative ( token , parser ) (Node) \u2014 The {% include_relative ... %} tag </> module","title":"liquid.tags.jekyll"},{"location":"api/liquid.tags/#liquidtagsshopify","text":"</> Provide shopify tagssee: https://shopify.dev/api/liquid/tags module","title":"liquid.tags.shopify"},{"location":"api/liquid.tags/#liquidtagswild","text":"</> Provides tags for wild mode Functions addfilter ( env , token , parser ) (Node) \u2014 The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} </> from_ ( env , token , parser ) (Node) \u2014 The from_ tag {% from_ ... %} </> import_ ( env , token , parser ) (Node) \u2014 The import_ tag {% import_ ... %} </> python ( env , token , parser ) (Node) \u2014 The python tag </> module","title":"liquid.tags.wild"},{"location":"api/liquid.tags/#liquidtagsmanager","text":"</> Provide tag manager Classes TagManager \u2014 A manager for tags </> Functions decode_raw ( body ) (str) \u2014 Decode the encoded string in body </>","title":"liquid.tags.manager"},{"location":"api/liquid.tags.shopify/","text":"module liquid.tags . shopify </> Provide shopify tagssee: https://shopify.dev/api/liquid/tags","title":"liquid.tags.shopify"},{"location":"api/liquid.tags.shopify/#liquidtagsshopify","text":"</> Provide shopify tagssee: https://shopify.dev/api/liquid/tags","title":"liquid.tags.shopify"},{"location":"api/liquid.tags.standard/","text":"module liquid.tags . standard </> Provides standard liquid tags Functions assign ( token , parser ) (Node) \u2014 The assign tag {% assign x = ... %} </> capture ( token , parser ) (Node) \u2014 The capture tag {% capture var %}...{% endcapture %} </> case ( token , parser ) (Node) \u2014 The case-when tag {% case x %}{% when y %} ... {% endcase %} </> comment ( token , parser ) (Node) \u2014 The comment tag {% comment %} ... {% endcomment %} </> cycle ( token , parser ) (Node) \u2014 The cycle tag {% cycle ... %} </> decrement ( token , parser ) (list of Node) \u2014 The decrement tag {% decrement x %} </> increment ( token , parser ) (list of Node) \u2014 The increment tag {% increment x %} </> tablerow ( token , parser ) (Union(node, list of node)) \u2014 The tablerow tag {% tablerow ... %} ... {% endtablerow %} </> unless ( token , parser ) (Node) \u2014 The unless tag {% unless ... %} ... {% endunless %} </> function liquid.tags.standard . comment ( token , parser ) </> The comment tag {% comment %} ... {% endcomment %} This tag accepts an argument, which is the prefix to be used for each line in the body. If no prefix provided, the entire body will be ignored (works as the one from liquid) Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.standard . capture ( token , parser ) </> The capture tag {% capture var %}...{% endcapture %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.standard . assign ( token , parser ) </> The assign tag {% assign x = ... %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.standard . unless ( token , parser ) </> The unless tag {% unless ... %} ... {% endunless %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.standard . case ( token , parser ) </> The case-when tag {% case x %}{% when y %} ... {% endcase %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.standard . tablerow ( token , parser ) </> The tablerow tag {% tablerow ... %} ... {% endtablerow %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Union(node, list of node)) The parsed node function liquid.tags.standard . increment ( token , parser ) </> The increment tag {% increment x %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (list of Node) The parsed node function liquid.tags.standard . decrement ( token , parser ) </> The decrement tag {% decrement x %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (list of Node) The parsed node function liquid.tags.standard . cycle ( token , parser ) </> The cycle tag {% cycle ... %} With name: {% cycle \"name\": \"one\", \"two\", \"three\" %} Without: {% cycle \"one\", \"two\", \"three\" %} Turn these to {{ loop.liquid_cycle(\"one\", \"two\", \"three\", name=...) }} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node","title":"liquid.tags.standard"},{"location":"api/liquid.tags.standard/#liquidtagsstandard","text":"</> Provides standard liquid tags Functions assign ( token , parser ) (Node) \u2014 The assign tag {% assign x = ... %} </> capture ( token , parser ) (Node) \u2014 The capture tag {% capture var %}...{% endcapture %} </> case ( token , parser ) (Node) \u2014 The case-when tag {% case x %}{% when y %} ... {% endcase %} </> comment ( token , parser ) (Node) \u2014 The comment tag {% comment %} ... {% endcomment %} </> cycle ( token , parser ) (Node) \u2014 The cycle tag {% cycle ... %} </> decrement ( token , parser ) (list of Node) \u2014 The decrement tag {% decrement x %} </> increment ( token , parser ) (list of Node) \u2014 The increment tag {% increment x %} </> tablerow ( token , parser ) (Union(node, list of node)) \u2014 The tablerow tag {% tablerow ... %} ... {% endtablerow %} </> unless ( token , parser ) (Node) \u2014 The unless tag {% unless ... %} ... {% endunless %} </> function","title":"liquid.tags.standard"},{"location":"api/liquid.tags.standard/#liquidtagsstandardcomment","text":"</> The comment tag {% comment %} ... {% endcomment %} This tag accepts an argument, which is the prefix to be used for each line in the body. If no prefix provided, the entire body will be ignored (works as the one from liquid) Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.standard.comment"},{"location":"api/liquid.tags.standard/#liquidtagsstandardcapture","text":"</> The capture tag {% capture var %}...{% endcapture %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.standard.capture"},{"location":"api/liquid.tags.standard/#liquidtagsstandardassign","text":"</> The assign tag {% assign x = ... %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.standard.assign"},{"location":"api/liquid.tags.standard/#liquidtagsstandardunless","text":"</> The unless tag {% unless ... %} ... {% endunless %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.standard.unless"},{"location":"api/liquid.tags.standard/#liquidtagsstandardcase","text":"</> The case-when tag {% case x %}{% when y %} ... {% endcase %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.standard.case"},{"location":"api/liquid.tags.standard/#liquidtagsstandardtablerow","text":"</> The tablerow tag {% tablerow ... %} ... {% endtablerow %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Union(node, list of node)) The parsed node function","title":"liquid.tags.standard.tablerow"},{"location":"api/liquid.tags.standard/#liquidtagsstandardincrement","text":"</> The increment tag {% increment x %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (list of Node) The parsed node function","title":"liquid.tags.standard.increment"},{"location":"api/liquid.tags.standard/#liquidtagsstandarddecrement","text":"</> The decrement tag {% decrement x %} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (list of Node) The parsed node function","title":"liquid.tags.standard.decrement"},{"location":"api/liquid.tags.standard/#liquidtagsstandardcycle","text":"</> The cycle tag {% cycle ... %} With name: {% cycle \"name\": \"one\", \"two\", \"three\" %} Without: {% cycle \"one\", \"two\", \"three\" %} Turn these to {{ loop.liquid_cycle(\"one\", \"two\", \"three\", name=...) }} Parameters token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node","title":"liquid.tags.standard.cycle"},{"location":"api/liquid.tags.wild/","text":"module liquid.tags . wild </> Provides tags for wild mode Functions addfilter ( env , token , parser ) (Node) \u2014 The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} </> from_ ( env , token , parser ) (Node) \u2014 The from_ tag {% from_ ... %} </> import_ ( env , token , parser ) (Node) \u2014 The import_ tag {% import_ ... %} </> python ( env , token , parser ) (Node) \u2014 The python tag </> function liquid.tags.wild . python ( env , token , parser ) </> The python tag {% python %} ... {% endpython %} or {% python ... %} The globals from the enviornment will be used to evaluate the code It also affect the globals from the environment Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches the tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.wild . import_ ( env , token , parser ) </> The import_ tag {% import_ ... %} Name it 'import_' so the 'import' tag from jinja can still work Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.wild . from_ ( env , token , parser ) </> The from_ tag {% from_ ... %} Name it 'from_' so the 'from_' tag from jinja can still work Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function liquid.tags.wild . addfilter ( env , token , parser ) </> The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} This allows one to use the python code inside the body to add a filter or replace an existing filter Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node","title":"liquid.tags.wild"},{"location":"api/liquid.tags.wild/#liquidtagswild","text":"</> Provides tags for wild mode Functions addfilter ( env , token , parser ) (Node) \u2014 The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} </> from_ ( env , token , parser ) (Node) \u2014 The from_ tag {% from_ ... %} </> import_ ( env , token , parser ) (Node) \u2014 The import_ tag {% import_ ... %} </> python ( env , token , parser ) (Node) \u2014 The python tag </> function","title":"liquid.tags.wild"},{"location":"api/liquid.tags.wild/#liquidtagswildpython","text":"</> The python tag {% python %} ... {% endpython %} or {% python ... %} The globals from the enviornment will be used to evaluate the code It also affect the globals from the environment Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches the tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.wild.python"},{"location":"api/liquid.tags.wild/#liquidtagswildimport_","text":"</> The import_ tag {% import_ ... %} Name it 'import_' so the 'import' tag from jinja can still work Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.wild.import_"},{"location":"api/liquid.tags.wild/#liquidtagswildfrom_","text":"</> The from_ tag {% from_ ... %} Name it 'from_' so the 'from_' tag from jinja can still work Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node function","title":"liquid.tags.wild.from_"},{"location":"api/liquid.tags.wild/#liquidtagswildaddfilter","text":"</> The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} This allows one to use the python code inside the body to add a filter or replace an existing filter Parameters env (Environment) \u2014 The environment token (Token) \u2014 The token matches tag name parser (Parser) \u2014 The parser Returns (Node) The parsed node","title":"liquid.tags.wild.addfilter"},{"location":"api/liquid.utils/","text":"module liquid . utils </> Some utils Functions parse_tag_args ( stream , name , lineno ) (Node) \u2014 Parse arguments for a tag. </> peek_tokens ( stream , n ) (list of Token) \u2014 Peek ahead 'n' tokens in the token stream, but don't move the cursor </> function liquid.utils . peek_tokens ( stream , n=1 ) </> Peek ahead 'n' tokens in the token stream, but don't move the cursor Parameters stream (TokenStream) \u2014 The token stream n (int, optional) \u2014 n tokens to look at Returns (list of Token) List of n tokens ahead. function liquid.utils . parse_tag_args ( stream , name , lineno ) </> Parse arguments for a tag. Only integer and name are allowed as values Examples >>> \"{{tablerow product in products cols:2}}\" >>> parse_tag_args ( stream , \"cols\" , lineno ) >>> # returns nodes.Const(2) Parameters stream (TokenStream) \u2014 The token stream name (str) \u2014 The name of the argument lineno (int) \u2014 The lineno Returns (Node) None if the argument is not pressent otherwise a Const or Name node","title":"liquid.utils"},{"location":"api/liquid.utils/#liquidutils","text":"</> Some utils Functions parse_tag_args ( stream , name , lineno ) (Node) \u2014 Parse arguments for a tag. </> peek_tokens ( stream , n ) (list of Token) \u2014 Peek ahead 'n' tokens in the token stream, but don't move the cursor </> function","title":"liquid.utils"},{"location":"api/liquid.utils/#liquidutilspeek_tokens","text":"</> Peek ahead 'n' tokens in the token stream, but don't move the cursor Parameters stream (TokenStream) \u2014 The token stream n (int, optional) \u2014 n tokens to look at Returns (list of Token) List of n tokens ahead. function","title":"liquid.utils.peek_tokens"},{"location":"api/liquid.utils/#liquidutilsparse_tag_args","text":"</> Parse arguments for a tag. Only integer and name are allowed as values Examples >>> \"{{tablerow product in products cols:2}}\" >>> parse_tag_args ( stream , \"cols\" , lineno ) >>> # returns nodes.Const(2) Parameters stream (TokenStream) \u2014 The token stream name (str) \u2014 The name of the argument lineno (int) \u2014 The lineno Returns (Node) None if the argument is not pressent otherwise a Const or Name node","title":"liquid.utils.parse_tag_args"},{"location":"api/source/liquid.defaults/","text":"SOURCE CODE liquid. defaults DOCS \"\"\"Provide default settings/values\"\"\" from typing import TYPE_CHECKING if TYPE_CHECKING : from .utils import PathTypeOrIter # The default mode to initialize a Liquid object # - standard: Compatible with standard liquid engine # - wild: liquid- and jinja-compatible engine # - jekyll: jekyll-compatible engine MODE : str = \"standard\" # Whether the template provided is a file path by default FROM_FILE : bool = True # Whether allow arguments of a filter to be separated # by colon (:) with the filter # e.g. {{ val | filter: arg1, arg2 }} # jinja only supports: # {{ val | filter(arg1, arg2)}} FILTER_WITH_COLON = True # The default search paths for templates # support absolute paths SEARCH_PATHS : \"PathTypeOrIter\" = [ \"/\" , \"./\" ] # The default format/language for the front matter # Should be one of yaml, toml or json FRONT_MATTER_LANG = \"yaml\" # Available jinja Environment arguments ENV_ARGS = [ \"block_start_string\" , \"block_end_string\" , \"variable_start_string\" , \"variable_end_string\" , \"comment_start_string\" , \"comment_end_string\" , \"line_statement_prefix\" , \"line_comment_prefix\" , \"trim_blocks\" , \"lstrip_blocks\" , \"newline_sequence\" , \"keep_trailing_newline\" , \"extensions\" , \"optimized\" , \"undefined\" , \"finalize\" , \"autoescape\" , \"loader\" , \"cache_size\" , \"auto_reload\" , \"bytecode_cache\" , \"enable_async\" , ] # In case some one wants to use nil SHARED_GLOBALS = { \"nil\" : None } # Whether treat filters as globals # Only works in wild mode FILTERS_AS_GLOBALS = True","title":"liquid.defaults"},{"location":"api/source/liquid.exts.ext/","text":"SOURCE CODE liquid.exts. ext DOCS \"\"\"Provides a base extension class\"\"\" import re from base64 import b64encode from typing import TYPE_CHECKING from jinja2 import nodes from jinja2.ext import Extension if TYPE_CHECKING : from jinja2.parser import Parser re_e = re . escape re_c = lambda rex : re . compile ( rex , re . M | re . S ) # A unique id to encode the start strings ENCODING_ID = id ( Extension ) class LiquidExtension ( Extension ): DOCS \"\"\"A base extension class for extensions in this package to extend\"\"\" def __init_subclass__ ( cls ) -> None : DOCS \"\"\"Initalize the tags and raw_tags using tag manager\"\"\" cls . tags = cls . tag_manager . names cls . raw_tags = cls . tag_manager . names_raw def preprocess ( # type: ignore DOCS self , source : str , name : str , filename : str , ) -> str : \"\"\"Try to keep the tag body raw by encode the variable/comment/block start strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. \"\"\" if not self . __class__ . raw_tags : # pragma: no cover return super () . preprocess ( source , name , filename = filename ) block_start_re = re_e ( self . environment . block_start_string ) block_end_re = re_e ( self . environment . block_end_string ) variable_start_re = re_e ( self . environment . variable_start_string ) comment_start_re = re_e ( self . environment . comment_start_string ) to_encode = re_c ( f \"( { block_start_re } | { variable_start_re } | { comment_start_re } )\" ) def encode_raw ( matched ): content = to_encode . sub ( lambda m : ( f \"$$ { ENCODING_ID } $\" f \" { b64encode ( m . group ( 1 ) . encode ()) . decode () } $$\" ), matched . group ( 2 ), ) return f \" { matched . group ( 1 ) }{ content }{ matched . group ( 3 ) } \" for raw_tag in self . __class__ . raw_tags : tag_re = re_c ( # {% comment \"//\" fr \"( { block_start_re } (?:\\-|\\+|)\\s* { raw_tag } \\s*.*?\" # %} fr \"(?:\\- { block_end_re } |\\+ { block_end_re } | { block_end_re } ))\" # ... fr \"(.*?)\" # {% endcomment fr \"( { block_start_re } (?:\\-|\\+|)\\s*end { raw_tag } \\s*\" fr \"(?:\\- { block_end_re } |\\+ { block_end_re } | { block_end_re } ))\" ) source = tag_re . sub ( encode_raw , source ) return source def parse ( self , parser : \"Parser\" ) -> nodes . Node : DOCS \"\"\"Let tag manager to parse the tags that are being listened to\"\"\" token = next ( parser . stream ) return self . __class__ . tag_manager . parse ( self . environment , token , parser )","title":"liquid.exts.ext"},{"location":"api/source/liquid.exts.filter_colon/","text":"SOURCE CODE liquid.exts. filter_colon DOCS \"\"\"Provides an extension to use colon to separate filter and its arguments Jinja uses `{{a | filter(arg)}}`, but liquid uses `{{a | filter: arg}}` \"\"\" from typing import TYPE_CHECKING , Iterable from jinja2.ext import Extension from jinja2.lexer import ( TOKEN_ASSIGN , TOKEN_BLOCK_END , TOKEN_COLON , TOKEN_LPAREN , TOKEN_NAME , TOKEN_PIPE , TOKEN_RPAREN , TOKEN_VARIABLE_END , Token , ) if TYPE_CHECKING : from jinja2.lexer import TokenStream class FilterColonExtension ( Extension ): DOCS \"\"\"This extension allows colon to be used to separate the filter and arguments, so that we can write django/liquid-style filters \"\"\" def filter_stream ( self , stream : \"TokenStream\" ) -> Iterable [ Token ]: DOCS \"\"\"Modify the colon to lparen and rparen tokens\"\"\" # expect a colon # 0: don't expect to change any {{a | filter: arg}} # to {{a | filter(arg)}} # 1: expect a filter # 2: expect the colon # 3: expect rparen flag = 0 for token in stream : # print(token.value, token.type) if flag == 0 and token . type is TOKEN_PIPE : flag = 1 yield token elif token . type is TOKEN_NAME and flag == 1 : flag = 2 yield token elif token . type is TOKEN_COLON and flag == 2 : flag = 3 yield Token ( token . lineno , TOKEN_LPAREN , None ) elif token . type is TOKEN_COLON and flag == 3 : # {{ a | filter: 1, x: 2}} => {{ a | filter: 1, x=2}} yield Token ( token . lineno , TOKEN_ASSIGN , None ) elif ( token . type in ( TOKEN_VARIABLE_END , TOKEN_BLOCK_END , TOKEN_PIPE ) and flag == 3 ): flag = 1 if token . type is TOKEN_PIPE else 0 yield Token ( token . lineno , TOKEN_RPAREN , None ) yield token else : yield token","title":"liquid.exts.filter_colon"},{"location":"api/source/liquid.exts.front_matter/","text":"SOURCE CODE liquid.exts. front_matter DOCS \"\"\"Provides an extension to allow front matter in the template\"\"\" from typing import TYPE_CHECKING from jinja2.ext import Extension from ..defaults import FRONT_MATTER_LANG if TYPE_CHECKING : from jinja2 import Environment class FrontMatterExtension ( Extension ): DOCS \"\"\"This extension allows to have front matter\"\"\" def __init__ ( self , environment : \"Environment\" ) -> None : super () . __init__ ( environment ) environment . extend ( front_matter_lang = FRONT_MATTER_LANG ) def preprocess ( self , source : str , name : str , filename : str = None ) -> str : DOCS \"\"\"Preprocess sourcee to extract front matter\"\"\" import frontmatter if self . environment . front_matter_lang . lower () == \"toml\" : from frontmatter.default_handlers import TOMLHandler as handler elif self . environment . front_matter_lang . lower () == \"json\" : from frontmatter.default_handlers import JSONHandler as handler else : from frontmatter.default_handlers import YAMLHandler as handler processed = frontmatter . loads ( source , handler = handler ()) self . environment . globals [ \"page\" ] = processed return processed . content","title":"liquid.exts.front_matter"},{"location":"api/source/liquid.exts.jekyll/","text":"SOURCE CODE liquid.exts. jekyll DOCS \"\"\"Extension for jekyll mode\"\"\" from ..tags.jekyll import jekyll_tags from .standard import LiquidStandardExtension class LiquidJekyllExtension ( LiquidStandardExtension ): DOCS \"\"\"Extension for jekyll mode\"\"\" tag_manager = jekyll_tags","title":"liquid.exts.jekyll"},{"location":"api/source/liquid.exts/","text":"SOURCE CODE liquid. exts DOCS","title":"liquid.exts"},{"location":"api/source/liquid.exts.shopify/","text":"SOURCE CODE liquid.exts. shopify DOCS \"\"\"Extension for shopify mode\"\"\" from ..tags.shopify import shopify_tags from .standard import LiquidStandardExtension class LiquidShopifyExtension ( LiquidStandardExtension ): DOCS \"\"\"Extension for jekyll mode\"\"\" tag_manager = shopify_tags","title":"liquid.exts.shopify"},{"location":"api/source/liquid.exts.standard/","text":"SOURCE CODE liquid.exts. standard DOCS \"\"\"Provides an extension to implment features for standard liquid\"\"\" from typing import TYPE_CHECKING , Generator from jinja2.lexer import ( TOKEN_ADD , TOKEN_COMMA , TOKEN_INTEGER , TOKEN_LPAREN , TOKEN_NAME , TOKEN_RPAREN , TOKEN_DOT , Token , ) from ..utils import peek_tokens from ..tags.standard import standard_tags from .ext import LiquidExtension if TYPE_CHECKING : from jinja2.lexer import TokenStream class LiquidStandardExtension ( LiquidExtension ): DOCS \"\"\"This extension implement features for standard liqiud These features (that jinja does support) including 1. Allow '.size' to get length of an array (by replacing it with '.__len__()') 2. Allow 'contains' to work as an operator by turning it into a test 3. Turn 'forloop' to 'loop' 4. Allow `(1..5)`, which will be turned to `range(1, 6)` \"\"\" tag_manager = standard_tags def __init__ ( self , environment ): super () . __init__ ( environment ) environment . tests [ \"contains\" ] = lambda cont , elm : cont . __contains__ ( elm ) def filter_stream ( self , stream : \"TokenStream\" ) -> Generator : DOCS \"\"\"Supports for liquid features\"\"\" for token in stream : # .size => .__len__() if token . type is TOKEN_DOT : if stream . current . test ( \"name:size\" ): stream . skip () # skip 'size' yield token yield Token ( token . lineno , \"name\" , \"__len__\" ) yield Token ( token . lineno , \"lparen\" , None ) yield Token ( token . lineno , \"rparen\" , None ) else : yield token # turn \"contains\" to \"is contains\" to use \"contains\" as a test elif token . test ( \"name:contains\" ): yield Token ( token . lineno , \"name\" , \"is\" ) yield token # turn forloop to loop elif token . test ( \"name:forloop\" ): # only when we do forloop.xxx if stream . current . type is TOKEN_DOT : yield Token ( token . lineno , \"name\" , \"loop\" ) else : yield token # (a..b) => range(a, b + 1) elif token . type is TOKEN_LPAREN and stream . current . type in ( TOKEN_NAME , TOKEN_INTEGER , ): tokens_ahead = peek_tokens ( stream , 5 ) # print(tokens_ahead) if ( len ( tokens_ahead ) < 5 or tokens_ahead [ 0 ] . type not in ( TOKEN_INTEGER , TOKEN_NAME ) or tokens_ahead [ 1 ] . type is not TOKEN_DOT or tokens_ahead [ 2 ] . type is not TOKEN_DOT or tokens_ahead [ 3 ] . type not in ( TOKEN_INTEGER , TOKEN_NAME ) or tokens_ahead [ 4 ] . type is not TOKEN_RPAREN ): yield token else : stream . skip ( 5 ) yield Token ( token . lineno , TOKEN_NAME , \"range\" ) yield Token ( token . lineno , TOKEN_LPAREN , None ) yield tokens_ahead [ 0 ] yield Token ( token . lineno , TOKEN_COMMA , None ) yield tokens_ahead [ 3 ] yield Token ( token . lineno , TOKEN_ADD , None ) yield Token ( token . lineno , TOKEN_INTEGER , 1 ) # type: ignore yield Token ( token . lineno , TOKEN_RPAREN , None ) else : yield token","title":"liquid.exts.standard"},{"location":"api/source/liquid.exts.wild/","text":"SOURCE CODE liquid.exts. wild DOCS \"\"\"Provides extension for wild mode\"\"\" from ..tags.wild import wild_tags from .ext import LiquidExtension class LiquidWildExtension ( LiquidExtension ): DOCS \"\"\"Extension for wild mode\"\"\" tag_manager = wild_tags","title":"liquid.exts.wild"},{"location":"api/source/liquid.filters.jekyll/","text":"SOURCE CODE liquid.filters. jekyll DOCS \"\"\"Provides jekyll filters See: https://jekyllrb.com/docs/liquid/filters/ \"\"\" import datetime import os import random import re import urllib.parse from typing import TYPE_CHECKING , Any , Sequence if TYPE_CHECKING : from jinja2.environment import Environment # environmentfilter deprecated try : from jinja2 import pass_environment except ImportError : from jinja2 import environmentfilter as pass_environment from jinja2.filters import FILTERS from .manager import FilterManager jekyll_filter_manager = FilterManager () def _getattr ( obj : Any , attr : str ) -> Any : \"\"\"Get attribute of an object, if fails, try get item\"\"\" try : return getattr ( obj , attr ) except AttributeError : return obj [ attr ] def _getattr_multi ( obj : Any , attr : str ) -> Any : \"\"\"Get attribute of an object at multiple levels For example: x.a.b = 1, _getattr_multi(x, \"a.b\") == 1 \"\"\" attrs = attr . split ( \".\" ) for att in attrs : try : obj = _getattr ( obj , att ) except ( TypeError , KeyError ): obj = None return obj def _get_global_var ( env : \"Environment\" , name : str , attr : str = None ) -> Any : if name not in env . globals : raise ValueError ( f \"Global variables has not been set: { name } \" ) out = env . globals [ name ] if attr is None : # pragma: no cover return out return _getattr ( out , attr ) jekyll_filter_manager . register ( \"group_by\" )( FILTERS [ \"groupby\" ]) jekyll_filter_manager . register ( \"to_integer\" )( FILTERS [ \"int\" ]) jekyll_filter_manager . register ( \"inspect\" )( repr ) @jekyll_filter_manager . register DOCS @pass_environment def relative_url ( env , value ): \"\"\"Get relative url based on site.baseurl\"\"\" baseurl = _get_global_var ( env , \"site\" , \"baseurl\" ) parts = urllib . parse . urlparse ( baseurl ) return os . path . join ( parts . path , value ) @jekyll_filter_manager . register DOCS @pass_environment def absolute_url ( env , value ): \"\"\"Get absolute url based on site.baseurl\"\"\" baseurl = _get_global_var ( env , \"site\" , \"baseurl\" ) return urllib . parse . urljoin ( baseurl , value ) @jekyll_filter_manager . register DOCS @pass_environment def date_to_xmlschema ( env , value : datetime . datetime ): \"\"\"Convert date to xml schema format\"\"\" return value . isoformat () # TODO: other date filters @jekyll_filter_manager . register DOCS @pass_environment def where_exp ( env , value , item , expr ): \"\"\"Where using expression\"\"\" compiled = env . compile_expression ( expr ) return [ itm for itm in value if compiled ( ** { item : itm })] @jekyll_filter_manager . register DOCS def find ( value , attr , query ): \"\"\"Find elements from array using attribute value\"\"\" for item in value : try : if _getattr ( item , attr ) == query : return item except ( KeyError , AttributeError ): continue return None @jekyll_filter_manager . register DOCS @pass_environment def find_exp ( env , value , item , expr ): \"\"\"Find elements using expression\"\"\" compiled = env . compile_expression ( expr ) for itm in value : try : test = compiled ( ** { item : itm }) except AttributeError : continue if test : return itm return None @jekyll_filter_manager . register DOCS @pass_environment def group_by_expr ( env , value , item , expr ): \"\"\"Group by data using expression\"\"\" compiled = env . compile_expression ( expr ) out = {} for itm in value : name = compiled ( ** { item : itm }) out . setdefault ( name , []) . append ( itm ) return [{ name : name , items : items } for name , items in out . items ()] @jekyll_filter_manager . register DOCS def xml_escape ( input : str ) -> str : \"\"\"Convert an object into its String representation Args: input: The object to be converted Returns: The converted string \"\"\" if input is None : return \"\" from xml.sax.saxutils import escape return escape ( input ) @jekyll_filter_manager . register DOCS def cgi_escape ( input : str ) -> str : \"\"\"CGI escape a string for use in a URL. Replaces any special characters with appropriate %XX replacements. Args: input: The string to escape Returns: The escaped string \"\"\" return urllib . parse . quote_plus ( input ) @jekyll_filter_manager . register DOCS def uri_escape ( input : str ) -> str : \"\"\"URI escape a string. Args: input: The string to escape Returns: The escaped string \"\"\" return urllib . parse . quote ( input , safe = \"!*'();:@&=+$,/?#[]\" ) # TODO: smartify, sassify, scssify @jekyll_filter_manager . register DOCS def jsonify ( input : Any ) -> str : \"\"\"Convert the input into json string Args: input: The Array or Hash to be converted Returns: The converted json string \"\"\" import json return json . dumps ( input ) @jekyll_filter_manager . register DOCS def array_to_sentence_string ( array : Sequence [ str ], connector : str = \"and\" , ) -> str : \"\"\"Join an array of things into a string by separating with commas and the word \"and\" for the last one. Args: array: The Array of Strings to join. connector: Word used to connect the last 2 items in the array Returns: The formatted string. \"\"\" if len ( array ) == 0 : return \"\" array = [ str ( elm ) for elm in array ] if len ( array ) == 1 : return array [ 0 ] if len ( array ) == 2 : return f \" { array [ 0 ] } { connector } { array [ 1 ] } \" return \", \" . join ( array [: - 1 ]) + f \", { connector } { array [ - 1 ] } \" @jekyll_filter_manager . register ( \"slugify\" ) DOCS def jekyll_slugify ( input : str , mode : str = \"default\" ) -> str : \"\"\"Slugify a string Note that non-ascii characters are always translated to ascii ones. Args: input: The input string mode: How string is slugified Returns: The slugified string \"\"\" if input is None or mode == \"none\" : return input from slugify import slugify # type: ignore if mode == \"pretty\" : return slugify ( input , regex_pattern = r \"[^_.~!$&'()+,;=@\\w]+\" ) if mode == \"raw\" : return slugify ( input , regex_pattern = r \"\\s+\" ) return slugify ( input ) @jekyll_filter_manager . register DOCS def number_of_words ( input : str , mode : str = None ) -> int : \"\"\"Count the number of words in the input string. Args: input: The String on which to operate. mode: Passing 'cjk' as the argument will count every CJK character detected as one word irrespective of being separated by whitespace. Passing 'auto' (auto-detect) works similar to 'cjk' Returns: The word count. \"\"\" import regex cjk_charset = r \"\\p {Han} \\p {Katakana} \\p {Hiragana} \\p {Hangul} \" cjk_regex = fr \"[ { cjk_charset } ]\" word_regex = fr \"[^ { cjk_charset } \\s]+\" if mode == \"cjk\" : return len ( regex . findall ( cjk_regex , input )) + len ( regex . findall ( word_regex , input ) ) if mode == \"auto\" : cjk_count = len ( regex . findall ( cjk_regex , input )) return ( len ( input . split ()) if cjk_count == 0 else cjk_count + len ( regex . findall ( word_regex , input )) ) return len ( input . split ()) @jekyll_filter_manager . register DOCS def markdownify ( value ): \"\"\"Markdownify a string\"\"\" from markdown import markdown # type: ignore return markdown ( value ) @jekyll_filter_manager . register DOCS def normalize_whitespace ( value ): \"\"\"Replace multiple spaces into one\"\"\" return re . sub ( r \"\\s+\" , \" \" , value ) @jekyll_filter_manager . register ( \"sort\" ) DOCS def jekyll_sort ( array : Sequence , prop : str = None , none_pos : str = \"first\" , ) -> Sequence : \"\"\"Sort an array in a reverse way by default. Note that the order might be different than it with ruby. For example, in python `\"1abc\" > \"1\"`, but it's not the case in jekyll. Also, it's always in reverse order for property values. Args: array: The array prop: property name none_pos: None order (first or last). Returns: The sorted array \"\"\" if array is None : raise ValueError ( \"Cannot sort None object.\" ) if none_pos not in ( \"first\" , \"last\" ): raise ValueError ( f \" { none_pos !r} is not a valid none_pos order. \" \"It must be 'first' or 'last'.\" ) if prop is None : non_none_arr = [ elm for elm in array if elm is not None ] n_none = len ( array ) - len ( non_none_arr ) sorted_arr = list ( sorted ( non_none_arr , reverse = True )) if none_pos == \"first\" : return [ None ] * n_none + sorted_arr return sorted_arr + [ None ] * n_none non_none_arr = [ elm for elm in array if _getattr_multi ( elm , prop ) is not None ] none_arr = [ elm for elm in array if _getattr_multi ( elm , prop ) is None ] sorted_arr = list ( sorted ( non_none_arr , key = lambda elm : _getattr_multi ( elm , prop ), reverse = True , ) ) if none_pos == \"first\" : return none_arr + sorted_arr return sorted_arr + none_arr @jekyll_filter_manager . register DOCS def sample ( value , n : int = 1 ): \"\"\"Sample elements from array\"\"\" return random . sample ( value , k = n )","title":"liquid.filters.jekyll"},{"location":"api/source/liquid.filters.manager/","text":"SOURCE CODE liquid.filters. manager DOCS \"\"\"Provides filter manager\"\"\" from typing import TYPE_CHECKING , Callable , Dict , Sequence , Union if TYPE_CHECKING : from jinja2 import Environment class FilterManager : DOCS \"\"\"A manager for filters Attributes: filters: a mapping of filter names to filters \"\"\" __slots__ = ( \"filters\" ,) def __init__ ( self ) -> None : \"\"\"Constructor\"\"\" self . filters : Dict [ str , Callable ] = {} def register ( DOCS self , name_or_filter : Union [ str , Sequence [ str ], Callable ] = None ) -> Callable : \"\"\"Register a filter This can be used as a decorator Examples: >>> @filter_manager.register >>> def add(a, b): >>> return a+b >>> # register it with an alias: >>> @filter_manager.register('addfunc') >>> def add(a, b): >>> return a+b Args: name_or_filter: The filter to register if name is given, will be treated as alias Returns: The registered function or the decorator \"\"\" def decorator ( filterfunc : Callable ) -> Callable : name = filterfunc . __name__ name = [ name ] # type: ignore if name_or_filter and name_or_filter is not filterfunc : names = name_or_filter if isinstance ( names , str ): names = ( nam . strip () for nam in names . split ( \",\" ) ) # type: ignore name = names # type: ignore for nam in name : self . filters [ nam ] = filterfunc return filterfunc if callable ( name_or_filter ): return decorator ( name_or_filter ) return decorator def update_to_env ( DOCS self , env : \"Environment\" , overwrite : bool = True ) -> None : \"\"\"Update the filters to environment Args: env: The environment to update these filters to overwrite: Whether overwrite existing filters in the env? \"\"\" if overwrite : env . filters . update ( self . filters ) filters = self . filters . copy () filters . update ( env . filters ) env . filters = filters","title":"liquid.filters.manager"},{"location":"api/source/liquid.filters/","text":"SOURCE CODE liquid. filters DOCS","title":"liquid.filters"},{"location":"api/source/liquid.filters.shopify/","text":"SOURCE CODE liquid.filters. shopify DOCS \"\"\"Provides shopify filters\"\"\" from .manager import FilterManager shopify_filter_manager = FilterManager () # TODO: color filters # https://shopify.dev/api/liquid/filters/color-filters # TODO: font filters # https://shopify.dev/api/liquid/filters/font-filters # TODO: html filters # https://shopify.dev/api/liquid/filters/html-filters # TODO: media filters # https://shopify.dev/api/liquid/filters/media-filters # TODO: metafield filters # https://shopify.dev/api/liquid/filters/metafield-filters # TODO: money filters # https://shopify.dev/api/liquid/filters/money-filters # TODO: string filters # https://shopify.dev/api/liquid/filters/string-filters # TODO: url filters # https://shopify.dev/api/liquid/filters/url-filters # TODO: additional filters # https://shopify.dev/api/liquid/filters/additional-filters","title":"liquid.filters.shopify"},{"location":"api/source/liquid.filters.standard/","text":"SOURCE CODE liquid.filters. standard DOCS \"\"\"Provides standard liquid filters\"\"\" import re import math import html from datetime import datetime from jinja2.filters import FILTERS from .manager import FilterManager standard_filter_manager = FilterManager () class DateTime : DOCS \"\"\"Date time allows plus/minus operation\"\"\" def __init__ ( self , dt : datetime , fmt : str ) -> None : self . dt = dt self . fmt = fmt def __str__ ( self ) -> str : DOCS \"\"\"How it is rendered\"\"\" return self . dt . strftime ( self . fmt ) def __add__ ( self , other : int ) -> int : return int ( str ( self )) + other def __sub__ ( self , other : int ) -> int : return int ( str ( self )) - other def __mul__ ( self , other : int ) -> int : return int ( str ( self )) * other def __floordiv__ ( self , other : int ) -> float : return float ( str ( self )) // other def __mod__ ( self , other : int ) -> int : return int ( str ( self )) % other def __pow__ ( self , other : int ) -> int : # pragma: no cover return int ( str ( self )) ** other def __truediv__ ( self , other : int ) -> float : # pragma: no cover return float ( str ( self )) / other def __radd__ ( self , other : int ) -> int : # pragma: no cover return other + int ( str ( self )) def __rsub__ ( self , other : int ) -> int : # pragma: no cover return other - int ( str ( self )) def __rmul__ ( self , other : int ) -> int : # pragma: no cover return other * int ( str ( self )) def __rmod__ ( self , other : int ) -> int : # pragma: no cover return other % int ( str ( self )) def __rpow__ ( self , other : int ) -> int : # pragma: no cover return other ** int ( str ( self )) def __rtruediv__ ( self , other : int ) -> float : # pragma: no cover return other / float ( str ( self )) def __rfloordiv__ ( self , other : int ) -> float : # pragma: no cover return other // float ( str ( self )) class EmptyDrop : DOCS \"\"\"The EmptyDrop class borrowed from liquid\"\"\" # Use jinja's Undefined instead? def __init__ ( self ): setattr ( self , \"empty?\" , True ) def __str__ ( self ): return \"\" def __eq__ ( self , other ): return not bool ( other ) def __ne__ ( self , other ): return not self . __eq__ ( other ) def __bool__ ( self ): return False def _get_prop ( obj , prop , _raise = False ): \"\"\"Get the property of the object, allow via getitem\"\"\" try : return obj [ prop ] except ( TypeError , KeyError ): try : return getattr ( obj , prop ) except AttributeError : if _raise : # pragma: no cover raise return None # Jinja comes with thses filters # standard_filter_manager.register(str.capitalize) # standard_filter_manager.register(abs) # standard_filter_manager.register(round) standard_filter_manager . register ( \"concat\" )( list . __add__ ) standard_filter_manager . register ( \"at_least\" )( max ) standard_filter_manager . register ( \"at_most\" )( min ) standard_filter_manager . register ( \"downcase\" )( str . lower ) standard_filter_manager . register ( \"upcase\" )( str . upper ) standard_filter_manager . register ( html . escape ) standard_filter_manager . register ( str . lstrip ) standard_filter_manager . register ( str . rstrip ) standard_filter_manager . register ( str . strip ) standard_filter_manager . register ( str . replace ) standard_filter_manager . register ( \"size\" )( len ) standard_filter_manager . register ( int ) standard_filter_manager . register ( float ) standard_filter_manager . register ( str ) standard_filter_manager . register ( bool ) @standard_filter_manager . register DOCS def split ( base , sep ): \"\"\"Split a string into a list If the sep is empty, return the list of characters \"\"\" if not sep : return list ( base ) return base . split ( sep ) @standard_filter_manager . register DOCS def append ( base , suffix ): \"\"\"Append a suffix to a string\"\"\" return f \" { base }{ suffix } \" @standard_filter_manager . register DOCS def prepend ( base , prefix ): \"\"\"Prepend a prefix to a string\"\"\" return f \" { prefix }{ base } \" @standard_filter_manager . register DOCS def times ( base , sep ): \"\"\"Implementation of *\"\"\" return base * sep @standard_filter_manager . register DOCS def minus ( base , sep ): \"\"\"Implementation of -\"\"\" return base - sep @standard_filter_manager . register DOCS def plus ( base , sep ): \"\"\"Implementation of +\"\"\" return base + sep @standard_filter_manager . register DOCS def modulo ( base , sep ): \"\"\"Implementation of %\"\"\" return base % sep @standard_filter_manager . register DOCS def ceil ( base ): \"\"\"Get the ceil of a number\"\"\" return math . ceil ( float ( base )) @standard_filter_manager . register DOCS def floor ( base ): \"\"\"Get the floor of a number\"\"\" return math . floor ( float ( base )) @standard_filter_manager . register ( \"date\" ) DOCS def liquid_date ( base , fmt ): \"\"\"Format a date/datetime\"\"\" if base == \"now\" : dtime = datetime . now () elif base == \"today\" : dtime = datetime . today () elif isinstance ( base , ( int , float )): dtime = datetime . fromtimestamp ( base ) else : from dateutil import parser # type: ignore dtime = parser . parse ( base ) return DateTime ( dtime , fmt ) @standard_filter_manager . register DOCS def default ( base , deft , allow_false = False ): \"\"\"Return the deft value if base is not set. Otherwise, return base\"\"\" if allow_false and base is False : return False if base is None : return deft return FILTERS [ \"default\" ]( base , deft , isinstance ( base , str )) @standard_filter_manager . register DOCS def divided_by ( base , dvdby ): \"\"\"Implementation of / or //\"\"\" if isinstance ( dvdby , int ): return base // dvdby return base / dvdby @standard_filter_manager . register DOCS def escape_once ( base ): \"\"\"Escapse html characters only once of the string\"\"\" return html . escape ( html . unescape ( base )) @standard_filter_manager . register DOCS def newline_to_br ( base ): \"\"\"Replace newline with `<br />`\"\"\" return base . replace ( \" \\n \" , \"<br />\" ) @standard_filter_manager . register DOCS def remove ( base , string ): \"\"\"Remove a substring from a string\"\"\" return base . replace ( string , \"\" ) @standard_filter_manager . register DOCS def remove_first ( base , string ): \"\"\"Remove the first substring from a string\"\"\" return base . replace ( string , \"\" , 1 ) @standard_filter_manager . register DOCS def replace_first ( base , old , new ): \"\"\"Replace the first substring with new string\"\"\" return base . replace ( old , new , 1 ) # @standard_filter_manager.register # def reverse(base): # \"\"\"Get the reversed list\"\"\" # if not base: # return EmptyDrop() # return list(reversed(base)) @standard_filter_manager . register DOCS def sort ( base ): \"\"\"Get the sorted list\"\"\" if not base : return EmptyDrop () return list ( sorted ( base )) @standard_filter_manager . register DOCS def sort_natural ( base ): \"\"\"Get the sorted list in a case-insensitive manner\"\"\" if not base : return EmptyDrop () return list ( sorted ( base , key = str . casefold )) @standard_filter_manager . register ( \"slice\" ) DOCS def liquid_slice ( base , start , length = 1 ): \"\"\"Slice a list\"\"\" if not base : return EmptyDrop () if start < 0 : start = len ( base ) + start end = None if length is None else start + length return base [ start : end ] @standard_filter_manager . register DOCS def strip_html ( base ): \"\"\"Strip html tags from a string\"\"\" # use html parser? return re . sub ( r \"<[^>]+>\" , \"\" , base ) @standard_filter_manager . register DOCS def strip_newlines ( base ): \"\"\"Strip newlines from a string\"\"\" return base . replace ( \" \\n \" , \"\" ) @standard_filter_manager . register DOCS def truncate ( base , length , ellipsis = \"...\" ): \"\"\"Truncate a string\"\"\" lenbase = len ( base ) if length >= lenbase : return base return base [: length - len ( ellipsis )] + ellipsis @standard_filter_manager . register DOCS def truncatewords ( base , length , ellipsis = \"...\" ): \"\"\"Truncate a string by words\"\"\" # do we need to preserve the whitespaces? baselist = base . split () lenbase = len ( baselist ) if length >= lenbase : return base # instead of collapsing them into just a single space? return \" \" . join ( baselist [: length ]) + ellipsis @standard_filter_manager . register DOCS def uniq ( base ): \"\"\"Get the unique elements from a list\"\"\" if not base : return EmptyDrop () ret = [] for bas in base : if bas not in ret : ret . append ( bas ) return ret @standard_filter_manager . register DOCS def url_decode ( base ): \"\"\"Url-decode a string\"\"\" try : from urllib import unquote except ImportError : from urllib.parse import unquote return unquote ( base ) @standard_filter_manager . register DOCS def url_encode ( base ): \"\"\"Url-encode a string\"\"\" try : from urllib import urlencode except ImportError : from urllib.parse import urlencode return urlencode ({ \"\" : base })[ 1 :] @standard_filter_manager . register DOCS def where ( base , prop , value ): \"\"\"Query a list of objects with a given property value\"\"\" ret = [ bas for bas in base if _get_prop ( bas , prop ) == value ] return ret or EmptyDrop () @standard_filter_manager . register ([ \"liquid_map\" , \"map\" ]) DOCS def liquid_map ( base , prop ): \"\"\"Map a property to a list of objects\"\"\" return [ _get_prop ( bas , prop ) for bas in base ] @standard_filter_manager . register DOCS def attr ( base , prop ): \"\"\"Similar as `__getattr__()` but also works like `__getitem__()\"\"\" return _get_prop ( base , prop ) # @standard_filter_manager.register # def join(base, sep): # \"\"\"Join a list by the sep\"\"\" # if isinstance(base, EmptyDrop): # return '' # return sep.join(base) # @standard_filter_manager.register # def first(base): # \"\"\"Get the first element of the list\"\"\" # if not base: # return EmptyDrop() # return base[0] # @standard_filter_manager.register # def last(base): # \"\"\"Get the last element of the list\"\"\" # if not base: # return EmptyDrop() # return base[-1] @standard_filter_manager . register DOCS def compact ( base ): \"\"\"Remove empties from a list\"\"\" ret = [ bas for bas in base if bas ] return ret or EmptyDrop () @standard_filter_manager . register DOCS def regex_replace ( base : str , regex : str , replace : str = \"\" , case_sensitive : bool = False , count : int = 0 , ) -> str : \"\"\"Replace matching regex pattern\"\"\" if not isinstance ( base , str ): # Raise an error instead? return base args = { \"pattern\" : regex , # re.escape \"repl\" : replace , \"string\" : base , \"count\" : count , } if not case_sensitive : args [ \"flags\" ] = re . IGNORECASE return re . sub ( ** args ) # type: ignore","title":"liquid.filters.standard"},{"location":"api/source/liquid.filters.wild/","text":"SOURCE CODE liquid.filters. wild DOCS \"\"\"Provides some wild filters\"\"\" try : from jinja2 import pass_environment except ImportError : from jinja2 import environmentfilter as pass_environment from typing import TYPE_CHECKING , Any from .manager import FilterManager if TYPE_CHECKING : from jinja2.environment import Environment wild_filter_manager = FilterManager () @wild_filter_manager . register ( \"ifelse, if_else\" ) DOCS @pass_environment def ifelse ( env : \"Environment\" , value : Any , test : Any , test_args : Any = (), true : Any = None , true_args : Any = (), false : Any = None , false_args : Any = (), ) -> Any : \"\"\"An if-else filter, implementing a tenary-like filter. Use `ifelse` or `if_else`. Examples: >>> {{ a | ifelse: isinstance, (int, ), >>> \"plus\", (1, ), >>> \"append\", (\".html\", ) }} >>> # 2 when a = 1 >>> # \"a.html\" when a = \"a\" Args: value: The base value test: The test callable or filter name test_args: Other args (value as the first arg) for the test true: The callable or filter name when test is True true_args: Other args (value as the first arg) for the true When this is None, return the true callable itself or the name of the filter it self false: The callable or filter name when test is False false_args: Other args (value as the first arg) for the false When this is None, return the false callable itself or the name of the filter it self Returns: The result of true of test result is True otherwise result of false. \"\"\" def compile_out ( func : Any , args : Any ) -> Any : if args is None : return func if not isinstance ( args , tuple ): args = ( args ,) if callable ( func ): return func ( value , * args ) expr = env . compile_expression ( f \"value | { func } (*args)\" ) return expr ( value = value , args = args ) test_out = compile_out ( test , test_args ) if test_out : return compile_out ( true , true_args ) return compile_out ( false , false_args )","title":"liquid.filters.wild"},{"location":"api/source/liquid.liquid/","text":"SOURCE CODE liquid. liquid DOCS \"\"\"Provides Liquid class\"\"\" import builtins from typing import Any , Callable , Mapping from jinja2 import ( Environment , ChoiceLoader , FileSystemLoader , ) from .filters.standard import standard_filter_manager from .utils import PathType , PathTypeOrIter class Liquid : DOCS \"\"\"The entrance for the package Examples: >>> Liquid('{{a}}', from_file=False) >>> Liquid('template.html') Args: template: The template string or path of the template file env: The jinja environment from_file: Whether `template` is a file path. If True, a `FileSystemLoader` will be used in the `env`. mode: The mode of the engine. - standard: Most compatibility with the standard liquid engine - jekyll: The jekyll-compatible mode - shopify: The shopify-compatible mode - wild: The liquid- and jinja-compatible mode filter_with_colon: Whether enable to use colon to separate filter and its arguments (i.e. `{{a | filter: arg}}`). If False, will fallback to use parentheses (`{{a | filter(arg)}}`) search_paths: The search paths for the template files. This only supports specification of paths. If you need so specify `encoding` and/or `followlinks`, you should use jinja's `FileSystemLoader` globals: Additional global values to be used to render the template filters: Additional filters be to used to render the template filters_as_globals: Whether also use filters as globals Only works in wild mode **kwargs: Other arguments for an jinja Environment construction and configurations for extensions \"\"\" __slots__ = ( \"env\" , \"template\" ) def __init__ ( self , template : PathType , from_file : bool = None , mode : str = None , env : Environment = None , filter_with_colon : bool = None , search_paths : PathTypeOrIter = None , globals : Mapping [ str , Any ] = None , filters : Mapping [ str , Callable ] = None , filters_as_globals : bool = None , ** kwargs : Any , ) -> None : \"\"\"Constructor\"\"\" # default values # fetch at runtime, so that they can be configured at importing from .defaults import ( FROM_FILE , MODE , FILTER_WITH_COLON , SEARCH_PATHS , ENV_ARGS , SHARED_GLOBALS , FILTERS_AS_GLOBALS , ) if from_file is None : from_file = FROM_FILE if mode is None : mode = MODE if filter_with_colon is None : filter_with_colon = FILTER_WITH_COLON if search_paths is None : search_paths = SEARCH_PATHS if filters_as_globals is None : filters_as_globals = FILTERS_AS_GLOBALS # split kwargs into arguments for Environment constructor and # configurations for extensions env_args = {} ext_conf = {} for key , val in kwargs . items (): if key in ENV_ARGS : env_args [ key ] = val else : ext_conf [ key ] = val loader = env_args . pop ( \"loader\" , None ) fsloader = FileSystemLoader ( search_paths ) # type: ignore if loader : loader = ChoiceLoader ([ loader , fsloader ]) else : loader = fsloader self . env = env = Environment ( ** env_args , loader = loader ) env . extend ( ** ext_conf ) env . globals . update ( SHARED_GLOBALS ) standard_filter_manager . update_to_env ( env ) env . add_extension ( \"jinja2.ext.loopcontrols\" ) if filter_with_colon : from .exts.filter_colon import FilterColonExtension env . add_extension ( FilterColonExtension ) if mode == \"wild\" : from .exts.wild import LiquidWildExtension from .filters.wild import wild_filter_manager env . add_extension ( \"jinja2.ext.debug\" ) env . add_extension ( LiquidWildExtension ) bfilters = { key : getattr ( builtins , key ) for key in dir ( builtins ) if not key . startswith ( \"_\" ) and callable ( getattr ( builtins , key )) and key not in ( \"copyright\" , \"credits\" , \"input\" , \"help\" , \"globals\" , \"license\" , \"locals\" , \"memoryview\" , \"object\" , \"property\" , \"staticmethod\" , \"super\" , ) and not any ( key_c . isupper () for key_c in key ) } env . filters . update ( bfilters ) wild_filter_manager . update_to_env ( env ) env . globals . update ( { key : val for key , val in __builtins__ . items () if not key . startswith ( \"_\" ) } ) if filters_as_globals : env . globals . update ( standard_filter_manager . filters ) env . globals . update ( wild_filter_manager . filters ) elif mode == \"jekyll\" : from .exts.front_matter import FrontMatterExtension from .exts.jekyll import LiquidJekyllExtension from .filters.jekyll import jekyll_filter_manager jekyll_filter_manager . update_to_env ( env ) env . add_extension ( FrontMatterExtension ) env . add_extension ( LiquidJekyllExtension ) elif mode == \"shopify\" : from .exts.shopify import LiquidShopifyExtension from .filters.shopify import shopify_filter_manager shopify_filter_manager . update_to_env ( env ) env . add_extension ( LiquidShopifyExtension ) else : # standard from .exts.standard import LiquidStandardExtension env . add_extension ( LiquidStandardExtension ) if filters : env . filters . update ( filters ) builtin_globals = { \"int\" : int , \"float\" : float , \"str\" : str , \"bool\" : bool } if globals : builtin_globals . update ( globals ) env . globals . update ( builtin_globals ) if from_file : # in case template is a PathLike self . template = env . get_template ( str ( template )) else : self . template = env . from_string ( str ( template )) def render ( self , * args , ** kwargs ) -> Any : DOCS \"\"\"Render the template. You can either pass the values using `tpl.render(a=1)` or `tpl.render({'a': 1})` \"\"\" return self . template . render ( * args , ** kwargs ) async def render_async ( self , * args , ** kwargs ) -> Any : DOCS \"\"\"Asynchronously render the template\"\"\" return await self . template . render_async ( * args , ** kwargs ) @classmethod DOCS def from_env ( cls , template : PathType , env : Environment , from_file : bool = None , filter_with_colon : bool = None , filters_as_globals : bool = None , mode : str = None , ) -> \"Liquid\" : \"\"\"Initiate a template from a jinja environment You should not specify any liquid-related extensions here. They will be added automatically. No search path is allow to be passed here. Instead, use jinja2's loaders or use the constructor to initialize a template. @Args: template: The template string or path of the template file env: The jinja environment from_file: Whether `template` is a file path. If True, a `FileSystemLoader` will be used in the `env`. filter_with_colon: Whether enable to use colon to separate filter and its arguments (i.e. `{{a | filter: arg}}`). If False, will fallback to use parentheses (`{{a | filter(arg)}}`) filters_as_globals: Whether also use filters as globals Only works in wild mode mode: The mode of the engine. - standard: Most compatibility with the standard liquid engine - wild: The liquid- and jinja-compatible mode - jekyll: The jekyll-compatible mode @Returns: A `Liquid` object \"\"\" return cls ( template , env = env , from_file = from_file , filter_with_colon = filter_with_colon , filters_as_globals = filters_as_globals , mode = mode , )","title":"liquid.liquid"},{"location":"api/source/liquid/","text":"SOURCE CODE liquid DOCS \"\"\"A port of liquid template engine for python on the shoulders of jinja2\"\"\" from .liquid import Liquid from .patching import patch_jinja , unpatch_jinja patch_jinja () __version__ = \"0.7.3\"","title":"liquid"},{"location":"api/source/liquid.patching/","text":"SOURCE CODE liquid. patching DOCS \"\"\"Patch a couple of jinja functions to implement some features that are impossible or too complex to be implemented by extensions Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for' \"\"\" from typing import Any from jinja2 import nodes from jinja2.parser import Parser from jinja2.runtime import LoopContext from .utils import parse_tag_args # patching Parser.parse_if to allow elsif in addition to elif # ----------------------------------------------------------- def parse_if ( self ) -> nodes . Node : node = result = nodes . If ( lineno = self . stream . expect ( \"name:if\" ) . lineno ) while True : node . test = self . parse_tuple ( with_condexpr = False ) node . body = self . parse_statements ( ( \"name:elif\" , \"name:elsif\" , \"name:else\" , \"name:endif\" ) ) node . elif_ = [] node . else_ = [] token = next ( self . stream ) if token . test_any ( \"name:elif\" , \"name:elsif\" ): node = nodes . If ( lineno = self . stream . current . lineno ) result . elif_ . append ( node ) continue elif token . test ( \"name:else\" ): result . else_ = self . parse_statements ( ( \"name:endif\" ,), drop_needle = True ) break return result jinja_nodes_if_fields = nodes . If . fields jinja_parse_if = Parser . parse_if # patching LoopContext to allow rindex and rindex0 # Also add liquid_cycle method to allow cycle to have a name # ----------------------------------------------------------- def cycle ( self , * args : Any , name : Any = None ) -> Any : if not hasattr ( self , \"_liquid_cyclers\" ): setattr ( self , \"_liquid_cyclers\" , {}) cyclers = self . _liquid_cyclers if name not in cyclers : cyclers [ name ] = [ args , - 1 ] cycler = cyclers [ name ] cycler [ 1 ] += 1 return cycler [ 0 ][ cycler [ 1 ] % len ( cycler [ 0 ])] # patching Parser.parse_for to allow arguments # ----------------------------------------------------------- def parse_for ( self ) -> nodes . Node : lineno = self . stream . expect ( \"name:for\" ) . lineno target = self . parse_assign_target ( extra_end_rules = ( \"name:in\" ,)) self . stream . expect ( \"name:in\" ) iter = self . parse_tuple ( with_condexpr = False , extra_end_rules = ( \"name:recursive\" , \"name:reversed\" , \"name:limit\" , \"name:offset\" , ), ) reverse = self . stream . skip_if ( \"name:reversed\" ) limit = parse_tag_args ( self . stream , \"limit\" , lineno ) offset = parse_tag_args ( self . stream , \"offset\" , lineno ) if limit and offset : limit = nodes . Add ( offset , limit ) if limit or offset : iter = nodes . Getitem ( iter , nodes . Slice ( offset , limit , None ), \"load\" ) if reverse : iter = nodes . Filter ( iter , \"reverse\" , [], [], None , None ) test = None if self . stream . skip_if ( \"name:if\" ): test = self . parse_expression () recursive = self . stream . skip_if ( \"name:recursive\" ) body = self . parse_statements (( \"name:endfor\" , \"name:else\" )) if next ( self . stream ) . value == \"endfor\" : else_ = [] else : else_ = self . parse_statements (( \"name:endfor\" ,), drop_needle = True ) return nodes . For ( target , iter , body , else_ , test , recursive , lineno = lineno ) jinja_parse_for = Parser . parse_for def patch_jinja (): DOCS \"\"\"Monkey-patch jinja\"\"\" nodes . If . fields = jinja_nodes_if_fields + ( \"elsif\" ,) nodes . If . elsif = None Parser . parse_if = parse_if LoopContext . rindex = LoopContext . revindex LoopContext . rindex0 = LoopContext . revindex0 LoopContext . liquid_cycle = cycle Parser . parse_for = parse_for def unpatch_jinja (): DOCS \"\"\"Restore the patches to jinja\"\"\" nodes . If . fields = jinja_nodes_if_fields del nodes . If . elsif Parser . parse_if = jinja_parse_if del LoopContext . rindex del LoopContext . rindex0 del LoopContext . liquid_cycle Parser . parse_for = jinja_parse_for","title":"liquid.patching"},{"location":"api/source/liquid.tags.jekyll/","text":"SOURCE CODE liquid.tags. jekyll DOCS \"\"\"Provides jekyll tags\"\"\" import os from jinja2 import nodes from jinja2.lexer import Token from jinja2.parser import Parser from .manager import TagManager from .standard import ( assign , capture , case , comment , cycle , decrement , increment , tablerow , unless , ) jekyll_tags = TagManager () jekyll_tags . register ( comment , raw = True ) jekyll_tags . register ( capture ) jekyll_tags . register ( assign ) jekyll_tags . register ( unless ) jekyll_tags . register ( case ) jekyll_tags . register ( tablerow ) jekyll_tags . register ( increment ) jekyll_tags . register ( decrement ) jekyll_tags . register ( cycle ) # to specify certain named arguments # use jinja's with # https://stackoverflow.com/a/9405157/5088165 @jekyll_tags . register DOCS def include_relative ( token : Token , parser : Parser ) -> nodes . Node : \"\"\"The {% include_relative ... %} tag\"\"\" node = nodes . Include ( lineno = token . lineno ) path = parser . parse_expression () if parser . stream . filename : node . template = nodes . Add ( nodes . Add ( nodes . Const ( os . path . dirname ( parser . stream . filename )), nodes . Const ( os . path . sep ), ), path , ) else : node . template = path node . ignore_missing = False return parser . parse_import_context ( node , True )","title":"liquid.tags.jekyll"},{"location":"api/source/liquid.tags.manager/","text":"SOURCE CODE liquid.tags. manager DOCS \"\"\"Provide tag manager\"\"\" import re from base64 import b64decode from typing import TYPE_CHECKING , Callable , Dict , Set , Union from jinja2 import nodes from jinja2.exceptions import TemplateSyntaxError if TYPE_CHECKING : from jinja2.lexer import Token from jinja2.parser import Parser from jinja2.environment import Environment from ..exts.ext import ENCODING_ID ENCODED_PATTERN = re . compile ( fr \"\\$\\$ { ENCODING_ID } \\$([\\w=+/]+)\\$\\$\" ) def decode_raw ( body : str ) -> str : DOCS \"\"\"Decode the encoded string in body The start string in body is encoded so that they won't be recognized as variable/comment/block by jinja. This way, we can protect the body from being tokenized. Args: body: The body Returns: The decoded string. \"\"\" return ENCODED_PATTERN . sub ( lambda m : b64decode ( m . group ( 1 )) . decode (), body , ) class TagManager : DOCS \"\"\"A manager for tags Attributes: tags: a mapping of tag names and parser functions envs: a mapping of tag names and whether environment should be passed to the parser functions raws: a mapping of tag names and whether the tag body should be kept raw. \"\"\" __slots__ = ( \"tags\" , \"envs\" , \"raws\" ) def __init__ ( self ) -> None : \"\"\"Constructor\"\"\" self . tags : Dict [ str , Callable ] = {} self . envs : Dict [ str , bool ] = {} self . raws : Dict [ str , bool ] = {} def register ( DOCS self , name_or_tagparser : Union [ str , Callable ] = None , env : bool = False , raw : bool = False , ) -> Callable : \"\"\"Register a filter This can be used as a decorator Examples: >>> @tag_manager.register >>> def comment(token, parser): >>> from jinja2 import nodes >>> return nodes.Const(\"\") Args: name_or_tagparser: The tag parser to register if name is given, will be treated as alias env: Whether we should pass environment to the parser raw: Whether we should keep the body of the tag raw Returns: The registered parser for the tag or a decorator \"\"\" def decorator ( tagparser : Callable ) -> Callable : name = tagparser . __name__ name = [ name ] # type: ignore if ( name_or_tagparser and name_or_tagparser is not tagparser ): # pragma: no cover names = name_or_tagparser if isinstance ( names , str ): names = ( nam . strip () for nam in names . split ( \",\" ) ) # type: ignore name = names # type: ignore for nam in name : self . tags [ nam ] = tagparser self . envs [ nam ] = env self . raws [ nam ] = raw return tagparser if callable ( name_or_tagparser ): return decorator ( name_or_tagparser ) return decorator @property DOCS def names ( self ) -> Set [ str ]: \"\"\"Get a set of the tag names\"\"\" return set ( self . tags ) @property DOCS def names_raw ( self ) -> Set [ str ]: \"\"\"Get a set of names of tags whose body will be kept raw\"\"\" return set ( raw for raw in self . raws if self . raws [ raw ]) def parse ( DOCS self , env : \"Environment\" , token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"Calling the parser functions to parse the tags Args: env: The environment token: The token matches the tag name parser: The parser Returns: The parsed node \"\"\" tagname = token . value if tagname not in self . tags : # pragma: no cover raise TemplateSyntaxError ( f \"Encountered unknown tag ' { tagname } '.\" , token . lineno , ) if self . envs . get ( tagname , False ): return self . tags [ tagname ]( env , token , parser ) return self . tags [ tagname ]( token , parser )","title":"liquid.tags.manager"},{"location":"api/source/liquid.tags/","text":"SOURCE CODE liquid. tags DOCS","title":"liquid.tags"},{"location":"api/source/liquid.tags.shopify/","text":"SOURCE CODE liquid.tags. shopify DOCS \"\"\"Provide shopify tags see: https://shopify.dev/api/liquid/tags \"\"\" from .manager import TagManager from .standard import ( comment , capture , assign , unless , case , tablerow , increment , decrement , cycle , ) shopify_tags = TagManager () shopify_tags . register ( comment , raw = True ) shopify_tags . register ( capture ) shopify_tags . register ( assign ) shopify_tags . register ( unless ) shopify_tags . register ( case ) shopify_tags . register ( tablerow ) shopify_tags . register ( increment ) shopify_tags . register ( decrement ) shopify_tags . register ( cycle ) # https://shopify.dev/api/liquid/tags/theme-tags # TODO: echo, form, layout, liquid, paginate, render, section, style","title":"liquid.tags.shopify"},{"location":"api/source/liquid.tags.standard/","text":"SOURCE CODE liquid.tags. standard DOCS \"\"\"Provides standard liquid tags\"\"\" from typing import TYPE_CHECKING , List , Union from jinja2 import nodes from jinja2.exceptions import TemplateSyntaxError from jinja2.lexer import TOKEN_BLOCK_END , TOKEN_COLON , TOKEN_STRING from ..utils import peek_tokens , parse_tag_args from .manager import TagManager , decode_raw if TYPE_CHECKING : from jinja2.parser import Parser from jinja2.lexer import Token standard_tags = TagManager () @standard_tags . register ( raw = True ) DOCS def comment ( token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The comment tag {% comment %} ... {% endcomment %} This tag accepts an argument, which is the prefix to be used for each line in the body. If no prefix provided, the entire body will be ignored (works as the one from liquid) Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" if parser . stream . current . type is TOKEN_BLOCK_END : # no args provided, ignore whatever parser . parse_statements (( \"name:endcomment\" , ), drop_needle = True ) return nodes . Output ([], lineno = token . lineno ) args = parser . parse_expression () body = parser . parse_statements (( \"name:endcomment\" , ), drop_needle = True ) body = decode_raw ( body [ 0 ] . nodes [ 0 ] . data ) body_parts = body . split ( \" \\n \" , 1 ) if not body_parts [ 0 ]: body = \"\" if len ( body_parts ) < 2 else body_parts [ 1 ] out = [ nodes . Const ( f \" { args . value } { line } \\n \" ) for line in body . splitlines ()] return nodes . Output ( out , lineno = token . lineno ) @standard_tags . register DOCS def capture ( token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The capture tag {% capture var %}...{% endcapture %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" target = parser . parse_assign_target ( with_namespace = True ) filter_node = parser . parse_filter ( None ) body = parser . parse_statements (( \"name:endcapture\" ,), drop_needle = True ) return nodes . AssignBlock ( target , filter_node , body , lineno = token . lineno ) @standard_tags . register DOCS def assign ( token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The assign tag {% assign x = ... %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" target = parser . parse_assign_target ( with_namespace = True ) parser . stream . expect ( \"assign\" ) expr = parser . parse_tuple () return nodes . Assign ( target , expr , lineno = token . lineno ) @standard_tags . register DOCS def unless ( token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The unless tag {% unless ... %} ... {% endunless %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" node = result = nodes . If ( lineno = token . lineno ) while True : node . test = nodes . Not ( parser . parse_tuple ( with_condexpr = False ), lineno = token . lineno , ) node . body = parser . parse_statements ( ( \"name:elif\" , \"name:elsif\" , \"name:else\" , \"name:endunless\" ) ) node . elif_ = [] node . else_ = [] token = next ( parser . stream ) if token . test_any ( \"name:elif\" , \"name:elsif\" ): node = nodes . If ( lineno = parser . stream . current . lineno ) result . elif_ . append ( node ) continue if token . test ( \"name:else\" ): result . else_ = parser . parse_statements ( ( \"name:endunless\" ,), drop_needle = True ) break return result @standard_tags . register DOCS def case ( token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The case-when tag {% case x %}{% when y %} ... {% endcase %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" lhs = parser . parse_tuple ( with_condexpr = False ) # %} if not parser . stream . skip_if ( \"block_end\" ): raise TemplateSyntaxError ( # pragma: no cover \"Expected 'end of statement block'\" , token . lineno , ) token = next ( parser . stream ) if token . type == \"data\" : if token . value . strip (): raise TemplateSyntaxError ( \"Expected nothing or whitespaces between case and when, \" f \"but got { token } \" , token . lineno , ) token = next ( parser . stream ) if token . type != \"block_begin\" : raise TemplateSyntaxError ( \"Expected 'begin of statement block', \" f \"but got { token } \" , token . lineno , ) token = parser . stream . expect ( \"name:when\" ) node = result = nodes . If ( lineno = token . lineno ) while True : node . test = nodes . Compare ( lhs , [ nodes . Operand ( \"eq\" , parser . parse_tuple ( with_condexpr = False ), ) ], lineno = token . lineno , ) node . body = parser . parse_statements ( ( \"name:when\" , \"name:else\" , \"name:endcase\" ) ) node . elif_ = [] node . else_ = [] token = next ( parser . stream ) if token . test ( \"name:when\" ): node = nodes . If ( lineno = parser . stream . current . lineno ) result . elif_ . append ( node ) continue if token . test ( \"name:else\" ): result . else_ = parser . parse_statements ( ( \"name:endcase\" ,), drop_needle = True ) break return result @standard_tags . register DOCS def tablerow ( token : \"Token\" , parser : \"Parser\" ) -> Union [ nodes . Node , List [ nodes . Node ]]: \"\"\"The tablerow tag {% tablerow ... %} ... {% endtablerow %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" target = parser . parse_assign_target ( extra_end_rules = ( \"name:in\" , )) parser . stream . expect ( \"name:in\" ) iter_ = parser . parse_tuple ( with_condexpr = False , extra_end_rules = ( \"name:cols\" , \"name:limit\" , \"name:offset\" ), ) cols = parse_tag_args ( parser . stream , \"cols\" , token . lineno ) limit = parse_tag_args ( parser . stream , \"limit\" , token . lineno ) offset = parse_tag_args ( parser . stream , \"offset\" , token . lineno ) if limit and offset : limit = nodes . Add ( offset , limit ) if limit or offset : iter_ = nodes . Getitem ( iter_ , nodes . Slice ( offset , limit , None ), \"load\" ) if cols : slice_start = nodes . Mul ( nodes . Name ( \"_tablerow_i\" , \"load\" ), cols ) inner_iter = nodes . Getitem ( iter_ , nodes . Slice ( slice_start , nodes . Add ( slice_start , cols ), None , ), \"load\" , ) else : inner_iter : nodes . Getitem = iter_ inner_body = [ nodes . Output ( [ nodes . Const ( '<td class=\"col' ), nodes . Getattr ( nodes . Name ( \"loop\" , \"load\" ), \"index\" , \"load\" ), nodes . Const ( '\">' ), ] ), * parser . parse_statements (( \"name:endtablerow\" ,), drop_needle = True ), nodes . Output ([ nodes . Const ( \"</td>\" )]), ] tr_begin = nodes . Output ( [ nodes . Const ( '<tr class=\"row' ), nodes . CondExpr ( nodes . Name ( \"loop\" , \"load\" ), nodes . Getattr ( nodes . Name ( \"loop\" , \"load\" ), \"index\" , \"load\" ), nodes . Const ( 1 ), ), nodes . Const ( '\">' ), ] ) tr_end = nodes . Output ([ nodes . Const ( \"</tr>\" )]) inner_loop = nodes . For ( target , inner_iter , inner_body , [], None , False , lineno = token . lineno ) if not cols : return [ tr_begin , inner_loop , tr_end ] # (iter_ | length) / cols iter_length = nodes . Div ( nodes . Filter ( iter_ , \"length\" , [], [], None , None ), cols , ) # float # int(iter_length) iter_length_int = nodes . Filter ( iter_length , \"int\" , [], [], None , None ) # implement ceil, as jinja's ceil is implemented as round(..., \"ceil\") # while liquid has a ceil filter # iter_length_int if iter_length == iter_length_int # else iter_length_int + 1 iter_length = nodes . CondExpr ( nodes . Compare ( iter_length , [ nodes . Operand ( \"eq\" , iter_length_int )]), iter_length_int , nodes . Add ( iter_length_int , nodes . Const ( 1 )), ) return nodes . For ( nodes . Name ( \"_tablerow_i\" , \"store\" ), nodes . Call ( nodes . Name ( \"range\" , \"load\" ), [ iter_length ], [], None , None ), [ tr_begin , inner_loop , tr_end ], [], None , False , lineno = token . lineno , ) @standard_tags . register DOCS def increment ( token : \"Token\" , parser : \"Parser\" ) -> List [ nodes . Node ]: \"\"\"The increment tag {% increment x %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" variable = parser . stream . expect ( \"name\" ) varname = f \"_liquid_xcrement_ { variable . value } \" varnode = nodes . Name ( varname , \"load\" ) return [ nodes . Assign ( nodes . Name ( varname , \"store\" ), nodes . CondExpr ( nodes . Test ( varnode , \"defined\" , [], [], None , None ), nodes . Add ( varnode , nodes . Const ( 1 )), nodes . Const ( 0 ), ), lineno = token . lineno , ), nodes . Output ([ varnode ], lineno = token . lineno ), ] @standard_tags . register DOCS def decrement ( token : \"Token\" , parser : \"Parser\" ) -> List [ nodes . Node ]: \"\"\"The decrement tag {% decrement x %} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" variable = parser . stream . expect ( \"name\" ) varname = f \"_liquid_xcrement_ { variable . value } \" varnode = nodes . Name ( varname , \"load\" ) return [ nodes . Assign ( nodes . Name ( varname , \"store\" ), nodes . CondExpr ( nodes . Test ( varnode , \"defined\" , [], [], None , None ), nodes . Sub ( varnode , nodes . Const ( 1 )), nodes . Const ( - 1 ), ), lineno = token . lineno , ), nodes . Output ([ varnode ], lineno = token . lineno ), ] @standard_tags . register DOCS def cycle ( token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The cycle tag {% cycle ... %} With name: {% cycle \"name\": \"one\", \"two\", \"three\" %} Without: {% cycle \"one\", \"two\", \"three\" %} Turn these to {{ loop.liquid_cycle(\"one\", \"two\", \"three\", name=...) }} Args: token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" tokens_ahead = peek_tokens ( parser . stream , 2 ) if ( len ( tokens_ahead ) == 2 and tokens_ahead [ 0 ] . type is TOKEN_STRING and tokens_ahead [ 1 ] . type is TOKEN_COLON ): parser . stream . skip ( 2 ) cycler_name = tokens_ahead [ 0 ] . value else : cycler_name = \"\" args = parser . parse_tuple ( with_condexpr = False , simplified = True ) return nodes . Output ( [ nodes . Call ( nodes . Getattr ( nodes . Name ( \"loop\" , \"load\" ), \"liquid_cycle\" , \"load\" ), args . items if isinstance ( args , nodes . Tuple ) else [ args ], [ nodes . Keyword ( \"name\" , nodes . Const ( cycler_name ))], None , None , lineno = token . lineno , ) ] )","title":"liquid.tags.standard"},{"location":"api/source/liquid.tags.wild/","text":"SOURCE CODE liquid.tags. wild DOCS \"\"\"Provides tags for wild mode\"\"\" import textwrap from contextlib import redirect_stdout from io import StringIO from typing import TYPE_CHECKING , List , Union from jinja2 import nodes from jinja2.exceptions import TemplateSyntaxError from jinja2.lexer import TOKEN_BLOCK_END try : from jinja2 import pass_environment except ImportError : from jinja2 import environmentfilter as pass_environment from .manager import TagManager , decode_raw from .standard import assign , capture , case , comment , cycle if TYPE_CHECKING : from jinja2.lexer import Token from jinja2.parser import Parser from jinja2.environment import Environment wild_tags = TagManager () wild_tags . register ( comment , raw = True ) wild_tags . register ( case ) wild_tags . register ( capture ) wild_tags . register ( assign ) wild_tags . register ( cycle ) @wild_tags . register ( raw = True , env = True ) DOCS def python ( env : \"Environment\" , token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The python tag {% python %} ... {% endpython %} or {% python ... %} The globals from the enviornment will be used to evaluate the code It also affect the globals from the environment Args: env: The environment token: The token matches the tag name parser: The parser Returns: The parsed node \"\"\" if parser . stream . current . type is TOKEN_BLOCK_END : # expect {% endpython %} body = parser . parse_statements (( \"name:endpython\" ,), drop_needle = True ) body = decode_raw ( body [ 0 ] . nodes [ 0 ] . data ) body_parts = body . split ( \" \\n \" , 1 ) if not body_parts [ 0 ]: body = \"\" if len ( body_parts ) < 2 else body_parts [ 1 ] body = textwrap . dedent ( body ) else : pieces : List [ str ] = [] pieces_append = pieces . append while True : token = next ( parser . stream ) pieces_append ( str ( token . value )) if parser . stream . current . type is TOKEN_BLOCK_END : break body = \" \" . join ( pieces ) code = compile ( body , \"<liquid-python-tag>\" , mode = \"exec\" ) out = StringIO () with redirect_stdout ( out ): exec ( code , env . globals ) return nodes . Output ([ nodes . Const ( out . getvalue ())], lineno = token . lineno ) @wild_tags . register ( env = True ) DOCS def import_ ( env : \"Environment\" , token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The import_ tag {% import_ ... %} Name it 'import_' so the 'import' tag from jinja can still work Args: env: The environment token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" pieces = [ \"import\" ] pieces_append = pieces . append while True : token = next ( parser . stream ) pieces_append ( str ( token . value )) if parser . stream . current . type is TOKEN_BLOCK_END : break body = \" \" . join ( pieces ) code = compile ( body , \"<liquid-import_-tag>\" , mode = \"exec\" ) exec ( code , env . globals ) return nodes . Output ([], lineno = token . lineno ) @wild_tags . register ( env = True ) DOCS def from_ ( env : \"Environment\" , token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The from_ tag {% from_ ... %} Name it 'from_' so the 'from_' tag from jinja can still work Args: env: The environment token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" pieces = [ \"from\" ] pieces_append = pieces . append while True : token = next ( parser . stream ) pieces_append ( str ( token . value )) if parser . stream . current . type is TOKEN_BLOCK_END : break body = \" \" . join ( pieces ) code = compile ( body , \"<liquid-from_-tag>\" , mode = \"exec\" ) exec ( code , env . globals ) return nodes . Output ([], lineno = token . lineno ) @wild_tags . register ( env = True , raw = True ) DOCS def addfilter ( env : \"Environment\" , token : \"Token\" , parser : \"Parser\" ) -> nodes . Node : \"\"\"The addfilter tag {% addfilter name ... %} ... {% endaddfilter %} This allows one to use the python code inside the body to add a filter or replace an existing filter Args: env: The environment token: The token matches tag name parser: The parser Returns: The parsed node \"\"\" token = parser . stream . expect ( \"name\" ) filtername = token . value pass_env : Union [ bool , Token ] if parser . stream . current . type is TOKEN_BLOCK_END : # no pass_environment pass_env = False else : pass_env = parser . stream . expect ( \"name:pass_env\" ) body = parser . parse_statements (( \"name:endaddfilter\" ,), drop_needle = True ) body = decode_raw ( body [ 0 ] . nodes [ 0 ] . data ) body_parts = body . split ( \" \\n \" , 1 ) if not body_parts [ 0 ]: body = \"\" if len ( body_parts ) < 2 else body_parts [ 1 ] body = textwrap . dedent ( body ) globs = env . globals . copy () code = compile ( body , \"<liquid-addfilter-tag>\" , mode = \"exec\" ) exec ( code , globs ) try : filterfunc = globs [ filtername ] except KeyError : raise TemplateSyntaxError ( f \"No such filter defined in 'addfilter': { filtername } \" , token . lineno , ) from None if pass_env : filterfunc = pass_environment ( filterfunc ) # type: ignore env . filters [ filtername ] = filterfunc return nodes . Output ([], lineno = token . lineno )","title":"liquid.tags.wild"},{"location":"api/source/liquid.utils/","text":"SOURCE CODE liquid. utils DOCS \"\"\"Some utils\"\"\" from os import PathLike from typing import TYPE_CHECKING , Iterable , List , Union from jinja2 import nodes from jinja2.lexer import TOKEN_INTEGER , TOKEN_NAME from jinja2.exceptions import TemplateSyntaxError if TYPE_CHECKING : from jinja2.lexer import TokenStream , Token PathType = Union [ PathLike , str ] PathTypeOrIter = Union [ PathType , Iterable [ PathType ]] def peek_tokens ( stream : \"TokenStream\" , n : int = 1 ) -> List [ \"Token\" ]: DOCS \"\"\"Peek ahead 'n' tokens in the token stream, but don't move the cursor Args: stream: The token stream n: n tokens to look at Returns: List of n tokens ahead. \"\"\" out = [] pushes = [] for _ in range ( n ): out . append ( next ( stream )) pushes . append ( stream . current ) for token in pushes : stream . push ( token ) stream . current = out [ 0 ] return out def parse_tag_args ( DOCS stream : \"TokenStream\" , name : str , lineno : int ) -> nodes . Node : \"\"\"Parse arguments for a tag. Only integer and name are allowed as values Examples: >>> \"{{tablerow product in products cols:2}}\" >>> parse_tag_args(stream, \"cols\", lineno) >>> # returns nodes.Const(2) Args: stream: The token stream name: The name of the argument lineno: The lineno Returns: None if the argument is not pressent otherwise a Const or Name node \"\"\" # use Parser.parse_primary? arg = stream . skip_if ( f \"name: { name } \" ) if not arg : return None stream . expect ( \"colon\" ) # tokens_ahead = peek_tokens(stream) if not stream . current . test_any ( TOKEN_INTEGER , TOKEN_NAME ): raise TemplateSyntaxError ( f \"Expected an integer or a variable as argument for ' { name } '.\" , lineno , ) arg = next ( stream ) if arg . type is TOKEN_INTEGER : return nodes . Const ( arg . value ) return nodes . Name ( arg . value , \"load\" )","title":"liquid.utils"}]}